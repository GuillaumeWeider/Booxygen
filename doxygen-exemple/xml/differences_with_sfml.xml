<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.13">
  <compounddef id="differences_with_sfml" kind="page">
    <compoundname>differences_with_sfml</compoundname>
    <title>Differences with SFML</title>
    <detaileddescription>
<para>Gamedev Framework (gf) tries to be compatible with SFML as much as possible. Nevertheless, there are some differences. Some of these differences are design choices while others are just missing features. This page tries to list all the differences so that porting applications from SFML to Gamedev Framework (gf) might be easier.</para><sect1 id="differences_with_sfml_1sfml_geometry">
<title>Geometry and colors</title>
<para>This is probably the most important difference with SFML. Gamedev Framework is built on a general purpose vector and matrix library that can be used directly. <ref refid="structgf_1_1_vector" kindref="compound">gf::Vector</ref> and <ref refid="structgf_1_1_matrix" kindref="compound">gf::Matrix</ref> provides all the necessary operations and functions.</para><para>As a consequence, there is no transform class. <ref refid="group__core_1gae702e6021057443ca43f94b32618bbc2" kindref="member">gf::Matrix3f</ref> is used instead to represent an affine transformation in the 2D plane. Usual transformations (translation, rotation, scaling) are provided as free functions.</para><para>In the same idea, there is no special color class. A color is just a vector. A difference with SFML is that <ref refid="group__core_1ga8c82c7df6d3bbd7f8d3601534b22a087" kindref="member">gf::Color4f</ref> uses floats to represents the four channels instead of bytes. Predefined colors can be accessed like SFML ones (e.g. <ref refid="structgf_1_1_color_1a7abeab052065d849d6a3f8b0d9ed57eb" kindref="member">gf::Color::Red</ref>).</para><para>Another big difference is that gf uses radians everywhere instead of degrees. You may have to change your function calls to transform degrees in radians. But generally, you would do the contrary: transform radians in degrees just for SFML.</para></sect1>
<sect1 id="differences_with_sfml_1sfml_textures">
<title>Textures</title>
<para>Contrary to SFML, texture coordinates are not given in pixels but in normalized coordinates (between 0 and 1). <formula id="80">$ (0,0) $</formula> represents the top-left corner while <formula id="120">$ (1,1) $</formula> represents the bottom-right corner. In case you change the resolution of your texture while keeping the same aspect ratio, you do not have to change the texture coordinates everywhere.</para><para>Gamedev Framework also has a special texture for fonts (<ref refid="classgf_1_1_alpha_texture" kindref="compound">gf::AlphaTexture</ref>). It is used internally by <ref refid="classgf_1_1_font" kindref="compound">gf::Font</ref> and it only has a single alpha channel to represent the font texture. The common operations between <ref refid="classgf_1_1_texture" kindref="compound">gf::Texture</ref> (which is the same as SFML Texture) and <ref refid="classgf_1_1_alpha_texture" kindref="compound">gf::AlphaTexture</ref> are put in the parent class <ref refid="classgf_1_1_bare_texture" kindref="compound">gf::BareTexture</ref>.</para></sect1>
<sect1 id="differences_with_sfml_1sfml_inheritance">
<title>No multiple inheritance</title>
<para>Multiple inheritance is bad. In gf, everything has been done to remove the various cases of multiple inheritance that exist in SFML.</para><para>First, there is no <computeroutput>NonCopyable</computeroutput> class. C++11 provides an easy way to make a class non-copyable with deleted constructors. So every instance of NonCopyable has been replaced with deleted copy constructor and assignement.</para><para>In SFML, drawable and transformable are two separate things. Yet, every transformable is a drawable. One could imagine to create a class that is transformable and not drawable but, in the library, it is not the case. So in gf, <ref refid="classgf_1_1_transformable" kindref="compound">gf::Transformable</ref> inherits <ref refid="classgf_1_1_drawable" kindref="compound">gf::Drawable</ref>.</para><para>Finally, another case of multiple inheritance is SFML render targets. In gf, render targets have been decoupled. For example, <ref refid="classgf_1_1_render_window" kindref="compound">gf::RenderWindow</ref> is not a <ref refid="classgf_1_1_window" kindref="compound">gf::Window</ref> (contrary to SFML), but it uses a window at initialization.</para></sect1>
<sect1 id="differences_with_sfml_1sfml_consistency">
<title>Consistency</title>
<para>Another field where SFML is sometimes surprising is consistency.</para><para>For example, the <computeroutput>setTexture()</computeroutput> method can take a pointer for shapes and a reference for sprites. It is explained by the fact that you can give a shape a null pointer to disable the texture. In gf, both method takes a reference for consistency and a <ref refid="classgf_1_1_shape_1a2d6252072140f0e2ee246e41a1e25684" kindref="member">gf::Shape::unsetTexture()</ref> method is provided if you want to disable the texture of the shape. This seems to be less surprising for the user (that hardly ever disables a texture in a shape).</para><para>If you want to set the color of an entity, there are two methods in SFML depending on the class: <computeroutput>setColor()</computeroutput> and <computeroutput>setFillColor()</computeroutput>. The second is used when the entity also has an outline color. And sometimes, the first method is deprecated in favor of the second (e.g. for text). In gf, there is only <computeroutput>setColor()</computeroutput> for every class, including those that have an outline color.</para><para>Naming of rectangles in SFML put the type first whereas it is put as a suffix for vectors. In gf, types are put as suffixes for all templated classes (<ref refid="structgf_1_1_rect" kindref="compound">gf::Rect</ref>, <ref refid="structgf_1_1_range" kindref="compound">gf::Range</ref>, <ref refid="structgf_1_1_vector" kindref="compound">gf::Vector</ref>, <ref refid="structgf_1_1_matrix" kindref="compound">gf::Matrix</ref>). So <computeroutput>IntRect</computeroutput> becomes <ref refid="group__core_1ga2e3cde0dd67f7db84ca4e8ba9ce1fa64" kindref="member">gf::RectI</ref>, and <computeroutput>FloatRect</computeroutput> becomes <ref refid="group__core_1gac3887a7df16895871374b04d9f6cb961" kindref="member">gf::RectF</ref>.</para></sect1>
<sect1 id="differences_with_sfml_1sfml_others">
<title>Others small differences</title>
<para>In gf::Inpustream, there is no error code for the return of the methods.</para></sect1>
<sect1 id="differences_with_sfml_1sfml_features">
<title>Additional features</title>
<para>Gamedev Framwork provides additional features that are not present in SFML. Here are only the features related to graphics, gf also has more high-level features related to games that are not described here.</para><para><ref refid="classgf_1_1_monitor" kindref="compound">gf::Monitor</ref> is a class that represents a monitor. You can list the monitors and get their position, size and modes.</para><para><ref refid="group__core_1ga6788e40b762777c1081f796076116a02" kindref="member">gf::Path</ref> is a typedef for <computeroutput>boost::filesystem::path</computeroutput>. It is used everywhere a path is needed.</para><para>gf provides more drawables that are useful in games: <ref refid="classgf_1_1_nine_patch" kindref="compound">gf::NinePatch</ref> is a <ulink url="http://developer.android.com/guide/topics/graphics/2d-graphics.html#nine-patch">nine patch</ulink> that can be used for UI rendering. <ref refid="classgf_1_1_animated_sprite" kindref="compound">gf::AnimatedSprite</ref> is a sprite with several frames that is used to render a simple graphic animation. <ref refid="classgf_1_1_post_processing" kindref="compound">gf::PostProcessing</ref> is a class that apply a <ref refid="classgf_1_1_effect" kindref="compound">gf::Effect</ref> to a texture. <ref refid="classgf_1_1_star_shape" kindref="compound">gf::StarShape</ref> is a <ref refid="classgf_1_1_shape" kindref="compound">gf::Shape</ref> that looks like a star. <ref refid="classgf_1_1_tile_layer" kindref="compound">gf::TileLayer</ref> is a class to render tile maps, <ref refid="classgf_1_1_curve" kindref="compound">gf::Curve</ref> is a family of curves (<ref refid="classgf_1_1_line" kindref="compound">gf::Line</ref>, <ref refid="classgf_1_1_quadratic_bezier_curve" kindref="compound">gf::QuadraticBezierCurve</ref>, <ref refid="classgf_1_1_cubic_bezier_curve" kindref="compound">gf::CubicBezierCurve</ref>, <ref refid="classgf_1_1_compound_curve" kindref="compound">gf::CompoundCurve</ref>).</para><para><ref refid="classgf_1_1_u_i" kindref="compound">gf::UI</ref> is a full-feature immediate mode GUI library.</para><para><ref refid="classgf_1_1_texture_atlas" kindref="compound">gf::TextureAtlas</ref> provides a texture atlas. It is capable of loading a XML file containing the atlas.</para><para><ref refid="classgf_1_1_sprite_batch" kindref="compound">gf::SpriteBatch</ref> is a simple sprite batch that is able to optimize the rendering of a great quantity of sprites that share the same characteristics (e.g. same texture).</para><para><ref refid="classgf_1_1_vertex_buffer" kindref="compound">gf::VertexBuffer</ref> represents a vertex buffer. A vertex buffer can be drawn with a <ref refid="classgf_1_1_buffered_geometry" kindref="compound">gf::BufferedGeometry</ref> drawable.</para><para>gf provides several views that adapts automatically to window size change. Different policy can be chosen (see <ref refid="classgf_1_1_adaptative_view" kindref="compound">gf::AdaptativeView</ref>).</para><para>In addition to primary and secondary colors, gf provides tertiary colors (whose name are rather standardized): <ref refid="structgf_1_1_color_1a4c17f95df10eb3ff5db17c96642b1a97" kindref="member">gf::Color::Orange</ref>, <ref refid="structgf_1_1_color_1ac79e589325b4f63dc23de41ca2bd7808" kindref="member">gf::Color::Rose</ref>, <ref refid="structgf_1_1_color_1af28c05348ba702440edcc6150d737b0a" kindref="member">gf::Color::Chartreuse</ref>, <ref refid="structgf_1_1_color_1a52ab1658ec597e2483615c8e04a7a217" kindref="member">gf::Color::Spring</ref>, <ref refid="structgf_1_1_color_1a4ce121f217dd0f565ab1e67daba493e0" kindref="member">gf::Color::Violet</ref>, <ref refid="structgf_1_1_color_1abdf2659559f4285f53a4337e64a67de5" kindref="member">gf::Color::Azure</ref>. Moreover, gf provides <ref refid="structgf_1_1_color_1ae5b4c2461eb305c1ec412d9df7414faa" kindref="member">gf::Color::lighter()</ref> and <ref refid="structgf_1_1_color_1a611b520b3122b4fa76647c0541cd1019" kindref="member">gf::Color::darker()</ref> that can be used to compute a lighter and darker color, while keeping the same hue.</para><para>Several drawables have a <computeroutput>setAnchor()</computeroutput> method (see <ref refid="group__graphics_1gadeb9cdf9d7e8eec2eb8cc638c54b5066" kindref="member">gf::Anchor</ref>). This method calls <computeroutput>setOrigin()</computeroutput> with the correct values according to the specified anchor and the local bounds of the drawables.</para><para>gf provides a binding to the excellent <ulink url="https://wiki.libsdl.org/CategoryGameController">Game Controller API of SDL</ulink> through the <ref refid="classgf_1_1_gamepad" kindref="compound">gf::Gamepad</ref> class. It loads the <ulink url="https://github.com/gabomdq/SDL_GameControllerDB">SDL_GameControllerDB</ulink> to handle most of the game controllers properly.</para></sect1>
<sect1 id="differences_with_sfml_1sfml_missing">
<title>Missing features</title>
<para>There is no Style in <ref refid="classgf_1_1_text" kindref="compound">gf::Text</ref>. This is a choice. Generally, you need an adapted font if you want italic or bold text.</para><para>Some part of the system module of SFML are missing. Especially the classes related to threads, <computeroutput>sf::String</computeroutput>. <computeroutput>sf::Utf</computeroutput>.</para></sect1>
<sect1 id="differences_with_sfml_1sfml_modules">
<title>Missing modules</title>
<para>There is no network module and no audio module. See <ref refid="recommanded_libraries" kindref="compound">Recommanded libraries</ref>. </para></sect1>
    </detaileddescription>
  </compounddef>
</doxygen>
