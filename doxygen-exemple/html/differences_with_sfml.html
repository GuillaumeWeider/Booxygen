<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Gamedev Framework (gf): Differences with SFML</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="custom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="gf_logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Gamedev Framework (gf)
   &#160;<span id="projectnumber">0.6.0</span>
   </div>
   <div id="projectbrief">A C++11 framework for 2D games</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Differences with SFML </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#sfml_geometry">Geometry and colors</a></li>
<li class="level1"><a href="#sfml_textures">Textures</a></li>
<li class="level1"><a href="#sfml_inheritance">No multiple inheritance</a></li>
<li class="level1"><a href="#sfml_consistency">Consistency</a></li>
<li class="level1"><a href="#sfml_others">Others small differences</a></li>
<li class="level1"><a href="#sfml_features">Additional features</a></li>
<li class="level1"><a href="#sfml_missing">Missing features</a></li>
<li class="level1"><a href="#sfml_modules">Missing modules</a></li>
</ul>
</div>
<div class="textblock"><p>Gamedev Framework (gf) tries to be compatible with SFML as much as possible. Nevertheless, there are some differences. Some of these differences are design choices while others are just missing features. This page tries to list all the differences so that porting applications from SFML to Gamedev Framework (gf) might be easier.</p>
<h1><a class="anchor" id="sfml_geometry"></a>
Geometry and colors</h1>
<p>This is probably the most important difference with SFML. Gamedev Framework is built on a general purpose vector and matrix library that can be used directly. <a class="el" href="structgf_1_1_vector.html" title="General purpose math vector. ">gf::Vector</a> and <a class="el" href="structgf_1_1_matrix.html" title="General purpose math matrix. ">gf::Matrix</a> provides all the necessary operations and functions.</p>
<p>As a consequence, there is no transform class. <a class="el" href="group__core.html#gae702e6021057443ca43f94b32618bbc2" title="A float square matrix of size 3. ">gf::Matrix3f</a> is used instead to represent an affine transformation in the 2D plane. Usual transformations (translation, rotation, scaling) are provided as free functions.</p>
<p>In the same idea, there is no special color class. A color is just a vector. A difference with SFML is that <a class="el" href="group__core.html#ga8c82c7df6d3bbd7f8d3601534b22a087" title="A float color vector with 4 components. ">gf::Color4f</a> uses floats to represents the four channels instead of bytes. Predefined colors can be accessed like SFML ones (e.g. <a class="el" href="structgf_1_1_color.html#a7abeab052065d849d6a3f8b0d9ed57eb" title="Red predefined color. ">gf::Color::Red</a>).</p>
<p>Another big difference is that gf uses radians everywhere instead of degrees. You may have to change your function calls to transform degrees in radians. But generally, you would do the contrary: transform radians in degrees just for SFML.</p>
<h1><a class="anchor" id="sfml_textures"></a>
Textures</h1>
<p>Contrary to SFML, texture coordinates are not given in pixels but in normalized coordinates (between 0 and 1). \( (0,0) \) represents the top-left corner while \( (1,1) \) represents the bottom-right corner. In case you change the resolution of your texture while keeping the same aspect ratio, you do not have to change the texture coordinates everywhere.</p>
<p>Gamedev Framework also has a special texture for fonts (<a class="el" href="classgf_1_1_alpha_texture.html" title="A texture with a single alpha channel. ">gf::AlphaTexture</a>). It is used internally by <a class="el" href="classgf_1_1_font.html" title="A character font. ">gf::Font</a> and it only has a single alpha channel to represent the font texture. The common operations between <a class="el" href="classgf_1_1_texture.html" title="A texture for colored images. ">gf::Texture</a> (which is the same as SFML Texture) and <a class="el" href="classgf_1_1_alpha_texture.html" title="A texture with a single alpha channel. ">gf::AlphaTexture</a> are put in the parent class <a class="el" href="classgf_1_1_bare_texture.html" title="An image that lives in the graphic memory that can be used for drawing. ">gf::BareTexture</a>.</p>
<h1><a class="anchor" id="sfml_inheritance"></a>
No multiple inheritance</h1>
<p>Multiple inheritance is bad. In gf, everything has been done to remove the various cases of multiple inheritance that exist in SFML.</p>
<p>First, there is no <code>NonCopyable</code> class. C++11 provides an easy way to make a class non-copyable with deleted constructors. So every instance of NonCopyable has been replaced with deleted copy constructor and assignement.</p>
<p>In SFML, drawable and transformable are two separate things. Yet, every transformable is a drawable. One could imagine to create a class that is transformable and not drawable but, in the library, it is not the case. So in gf, <a class="el" href="classgf_1_1_transformable.html" title="Decomposed transform defined by a position, a rotation and a scale. ">gf::Transformable</a> inherits <a class="el" href="classgf_1_1_drawable.html" title="Abstract base class for objects that can be drawn to a render window. ">gf::Drawable</a>.</p>
<p>Finally, another case of multiple inheritance is SFML render targets. In gf, render targets have been decoupled. For example, <a class="el" href="classgf_1_1_render_window.html" title="A window that can serve as a target for 2D drawing. ">gf::RenderWindow</a> is not a <a class="el" href="classgf_1_1_window.html" title="An OS window. ">gf::Window</a> (contrary to SFML), but it uses a window at initialization.</p>
<h1><a class="anchor" id="sfml_consistency"></a>
Consistency</h1>
<p>Another field where SFML is sometimes surprising is consistency.</p>
<p>For example, the <code>setTexture()</code> method can take a pointer for shapes and a reference for sprites. It is explained by the fact that you can give a shape a null pointer to disable the texture. In gf, both method takes a reference for consistency and a <a class="el" href="classgf_1_1_shape.html#a2d6252072140f0e2ee246e41a1e25684" title="Unset the source texture of the shape. ">gf::Shape::unsetTexture()</a> method is provided if you want to disable the texture of the shape. This seems to be less surprising for the user (that hardly ever disables a texture in a shape).</p>
<p>If you want to set the color of an entity, there are two methods in SFML depending on the class: <code>setColor()</code> and <code>setFillColor()</code>. The second is used when the entity also has an outline color. And sometimes, the first method is deprecated in favor of the second (e.g. for text). In gf, there is only <code>setColor()</code> for every class, including those that have an outline color.</p>
<p>Naming of rectangles in SFML put the type first whereas it is put as a suffix for vectors. In gf, types are put as suffixes for all templated classes (<a class="el" href="structgf_1_1_rect.html" title="Utility class for manipulating 2D axis aligned rectangles. ">gf::Rect</a>, <a class="el" href="structgf_1_1_range.html" title="A half-open range of values. ">gf::Range</a>, <a class="el" href="structgf_1_1_vector.html" title="General purpose math vector. ">gf::Vector</a>, <a class="el" href="structgf_1_1_matrix.html" title="General purpose math matrix. ">gf::Matrix</a>). So <code>IntRect</code> becomes <a class="el" href="group__core.html#ga2e3cde0dd67f7db84ca4e8ba9ce1fa64" title="A int rectangle. ">gf::RectI</a>, and <code>FloatRect</code> becomes <a class="el" href="group__core.html#gac3887a7df16895871374b04d9f6cb961" title="A float rectangle. ">gf::RectF</a>.</p>
<h1><a class="anchor" id="sfml_others"></a>
Others small differences</h1>
<p>In gf::Inpustream, there is no error code for the return of the methods.</p>
<h1><a class="anchor" id="sfml_features"></a>
Additional features</h1>
<p>Gamedev Framwork provides additional features that are not present in SFML. Here are only the features related to graphics, gf also has more high-level features related to games that are not described here.</p>
<p><a class="el" href="classgf_1_1_monitor.html" title="A monitor. ">gf::Monitor</a> is a class that represents a monitor. You can list the monitors and get their position, size and modes.</p>
<p><a class="el" href="group__core.html#ga6788e40b762777c1081f796076116a02" title="A path in the filesystem. ">gf::Path</a> is a typedef for <code>boost::filesystem::path</code>. It is used everywhere a path is needed.</p>
<p>gf provides more drawables that are useful in games: <a class="el" href="classgf_1_1_nine_patch.html" title="A nine-patch. ">gf::NinePatch</a> is a <a href="http://developer.android.com/guide/topics/graphics/2d-graphics.html#nine-patch">nine patch</a> that can be used for UI rendering. <a class="el" href="classgf_1_1_animated_sprite.html" title="An animated sprite. ">gf::AnimatedSprite</a> is a sprite with several frames that is used to render a simple graphic animation. <a class="el" href="classgf_1_1_post_processing.html" title="A post-processing drawable. ">gf::PostProcessing</a> is a class that apply a <a class="el" href="classgf_1_1_effect.html" title="A post-processing effect. ">gf::Effect</a> to a texture. <a class="el" href="classgf_1_1_star_shape.html" title="Specialized shape representing a star. ">gf::StarShape</a> is a <a class="el" href="classgf_1_1_shape.html" title="Base class for textured shapes with outline. ">gf::Shape</a> that looks like a star. <a class="el" href="classgf_1_1_tile_layer.html" title="A tile layer. ">gf::TileLayer</a> is a class to render tile maps, <a class="el" href="classgf_1_1_curve.html" title="A curve is a one dimension object. ">gf::Curve</a> is a family of curves (<a class="el" href="classgf_1_1_line.html" title="A line. ">gf::Line</a>, <a class="el" href="classgf_1_1_quadratic_bezier_curve.html" title="A quadratic Bézier curve. ">gf::QuadraticBezierCurve</a>, <a class="el" href="classgf_1_1_cubic_bezier_curve.html" title="A cubic Bézier curve. ">gf::CubicBezierCurve</a>, <a class="el" href="classgf_1_1_compound_curve.html" title="A compound curve. ">gf::CompoundCurve</a>).</p>
<p><a class="el" href="classgf_1_1_u_i.html" title="Context for an immediate mode graphical interface. ">gf::UI</a> is a full-feature immediate mode GUI library.</p>
<p><a class="el" href="classgf_1_1_texture_atlas.html" title="A collection of sub-texture. ">gf::TextureAtlas</a> provides a texture atlas. It is capable of loading a XML file containing the atlas.</p>
<p><a class="el" href="classgf_1_1_sprite_batch.html" title="A sprite batch. ">gf::SpriteBatch</a> is a simple sprite batch that is able to optimize the rendering of a great quantity of sprites that share the same characteristics (e.g. same texture).</p>
<p><a class="el" href="classgf_1_1_vertex_buffer.html" title="Data in the graphics memory. ">gf::VertexBuffer</a> represents a vertex buffer. A vertex buffer can be drawn with a <a class="el" href="classgf_1_1_buffered_geometry.html" title="A drawable for buffers. ">gf::BufferedGeometry</a> drawable.</p>
<p>gf provides several views that adapts automatically to window size change. Different policy can be chosen (see <a class="el" href="classgf_1_1_adaptative_view.html" title="Adaptative view. ">gf::AdaptativeView</a>).</p>
<p>In addition to primary and secondary colors, gf provides tertiary colors (whose name are rather standardized): <a class="el" href="structgf_1_1_color.html#a4c17f95df10eb3ff5db17c96642b1a97" title="Orange predefined color. ">gf::Color::Orange</a>, <a class="el" href="structgf_1_1_color.html#ac79e589325b4f63dc23de41ca2bd7808" title="Rose predefined color. ">gf::Color::Rose</a>, <a class="el" href="structgf_1_1_color.html#af28c05348ba702440edcc6150d737b0a" title="Chartreuse predefined color. ">gf::Color::Chartreuse</a>, <a class="el" href="structgf_1_1_color.html#a52ab1658ec597e2483615c8e04a7a217" title="Spring (green) predefined color. ">gf::Color::Spring</a>, <a class="el" href="structgf_1_1_color.html#a4ce121f217dd0f565ab1e67daba493e0" title="Violet predefined color. ">gf::Color::Violet</a>, <a class="el" href="structgf_1_1_color.html#abdf2659559f4285f53a4337e64a67de5" title="Azure predefined color. ">gf::Color::Azure</a>. Moreover, gf provides <a class="el" href="structgf_1_1_color.html#ae5b4c2461eb305c1ec412d9df7414faa" title="Compute a lighter color. ">gf::Color::lighter()</a> and <a class="el" href="structgf_1_1_color.html#a611b520b3122b4fa76647c0541cd1019" title="Compute a darker color. ">gf::Color::darker()</a> that can be used to compute a lighter and darker color, while keeping the same hue.</p>
<p>Several drawables have a <code>setAnchor()</code> method (see <a class="el" href="group__graphics.html#gadeb9cdf9d7e8eec2eb8cc638c54b5066" title="An anchor of a box. ">gf::Anchor</a>). This method calls <code>setOrigin()</code> with the correct values according to the specified anchor and the local bounds of the drawables.</p>
<p>gf provides a binding to the excellent <a href="https://wiki.libsdl.org/CategoryGameController">Game Controller API of SDL</a> through the <a class="el" href="classgf_1_1_gamepad.html" title="Some gamepad related functions. ">gf::Gamepad</a> class. It loads the <a href="https://github.com/gabomdq/SDL_GameControllerDB">SDL_GameControllerDB</a> to handle most of the game controllers properly.</p>
<h1><a class="anchor" id="sfml_missing"></a>
Missing features</h1>
<p>There is no Style in <a class="el" href="classgf_1_1_text.html" title="Graphical text that can be drawn to a render target. ">gf::Text</a>. This is a choice. Generally, you need an adapted font if you want italic or bold text.</p>
<p>Some part of the system module of SFML are missing. Especially the classes related to threads, <code>sf::String</code>. <code>sf::Utf</code>.</p>
<h1><a class="anchor" id="sfml_modules"></a>
Missing modules</h1>
<p>There is no network module and no audio module. See <a class="el" href="recommanded_libraries.html">Recommanded libraries</a>. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
