<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Gamedev Framework (gf): How to write your own shader</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="custom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="gf_logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Gamedev Framework (gf)
   &#160;<span id="projectnumber">0.6.0</span>
   </div>
   <div id="projectbrief">A C++11 framework for 2D games</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">How to write your own shader </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#shader_intro">Introduction</a></li>
<li class="level1"><a href="#shader_default">Default shaders</a><ul><li class="level2"><a href="#shader_default_vertex_shader">Default vertex shader</a></li>
<li class="level2"><a href="#shader_default_fragment_shader">Default fragment shader</a></li>
</ul>
</li>
<li class="level1"><a href="#shader_user_shader">User provided shader</a></li>
<li class="level1"><a href="#shader_post_processing">Post-processing</a></li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="shader_intro"></a>
Introduction</h1>
<p>This is a quick and dirty introduction to modern OpenGL rendering pipeline. If you already know everything then you can go to the next section.</p>
<p>In modern OpenGL, the rendering pipeline is programmable. Not everything is programmable but the most important parts. You have to use a special language called <a href="https://en.wikipedia.org/wiki/OpenGL_Shading_Language">GLSL</a> (OpenGL Shading Language) and make programs called shaders.</p>
<p>The data you send to shaders is prepared in the main program and is called vertices. Vertices represent the geometry of what you have to draw. A vertex is a kind of super point: it contains the coordinates of the object but also the texture coordinates of the point, sometimes (in 3D) the normal of the surface at that point, and many more possible things.</p>
<p>All the vertices are sent to the graphics card that passes them to the <em>vertex shader</em> which is responsible of transforming the coordinates of the vertex from the game world (2D or 3D) to the screen. After this first pass, the vertices go in the rasterizer which computes the color of each pixel. Then, the pixels go through a <em>fragment shader</em> which can compute the final color of the pixel and sometimes other attributes.</p>
<p>And that's it, basically!</p>
<dl class="section see"><dt>See also</dt><dd><a href="https://www.opengl.org/wiki/Rendering_Pipeline_Overview">Rendering pipeline overview - OpenGL.org</a></dd></dl>
<h1><a class="anchor" id="shader_default"></a>
Default shaders</h1>
<p>In gf, every draw command ends in a shader. If no shader is specified, then a default shader is used.</p>
<h2><a class="anchor" id="shader_default_vertex_shader"></a>
Default vertex shader</h2>
<p>Here is the default vertex shader:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#version 100</span></div><div class="line"></div><div class="line"><span class="comment">// The attributes of the vertex:</span></div><div class="line"><span class="comment">// - position in the game world</span></div><div class="line"><span class="comment">// - color of the vertex</span></div><div class="line"><span class="comment">// - texture coordinates</span></div><div class="line"></div><div class="line">attribute vec2 a_position;</div><div class="line">attribute vec4 a_color;</div><div class="line">attribute vec2 a_texCoords;</div><div class="line"></div><div class="line"><span class="comment">// The outputs of the shader that will be passed to the fragment shader</span></div><div class="line"><span class="comment">// - color of the vertex</span></div><div class="line"><span class="comment">// - texture coordinates</span></div><div class="line"></div><div class="line">varying vec4 v_color;</div><div class="line">varying vec2 v_texCoords;</div><div class="line"></div><div class="line"><span class="comment">// The transformation matrix for the object.</span></div><div class="line"><span class="comment">// It is a constant (uniform) accross all vertices.</span></div><div class="line"></div><div class="line">uniform mat3 u_transform;</div><div class="line"></div><div class="line"><span class="comment">// The main program starts here.</span></div><div class="line"></div><div class="line"><span class="keywordtype">void</span> main(<span class="keywordtype">void</span>) {</div><div class="line"></div><div class="line">  <span class="comment">// First, pass the texture coordinates and color to the fragment shader</span></div><div class="line"></div><div class="line">  v_texCoords = a_texCoords;</div><div class="line">  v_color = a_color;</div><div class="line"></div><div class="line">  <span class="comment">// Then compute the coordinate on the screen of the vertex.</span></div><div class="line">  <span class="comment">// For this, you have to compute the homogeneous coordinate of the position.</span></div><div class="line"></div><div class="line">  vec3 worldPosition = vec3(a_position, 1);</div><div class="line"></div><div class="line">  <span class="comment">// And multiply by the transformation matrix.</span></div><div class="line"></div><div class="line">  vec3 normalizedPosition = worldPosition * u_transform;</div><div class="line"></div><div class="line">  <span class="comment">// The output is the final position of the vertex on the screen.</span></div><div class="line"></div><div class="line">  gl_Position = vec4(normalizedPosition.xy, 0, 1);</div><div class="line">}</div></div><!-- fragment --><p><a class="el" href="structgf_1_1_vertex.html" title="A point associated with a color and a texture coordinate. ">gf::Vertex</a> contains the data that is passed to this vertex shader. When you call <a class="el" href="classgf_1_1_render_target.html#a3445880f95c648efbeff3d2572c4c263" title="Draw primitives defined by an array of vertices. ">gf::RenderTarget::draw()</a>, you have to provide an array of <a class="el" href="structgf_1_1_vertex.html" title="A point associated with a color and a texture coordinate. ">gf::Vertex</a> which is then handled by the shader:</p>
<ul>
<li>The <code>position</code> attribute becomes <code>a_position</code> in the shader</li>
<li>The <code>color</code> attribute becomes <code>a_color</code> in the shader</li>
<li>The <code>texCoords</code> attribute becomes <code>a_texCoords</code> in the shader</li>
</ul>
<p>The <code>u_transform</code> constant is set by the library automatically. It is computed from the global transform matrix put in <a class="el" href="structgf_1_1_render_states.html" title="Define the states used for drawing to a RenderTarget. ">gf::RenderStates</a> and from the object transform matrix (see <a class="el" href="classgf_1_1_transformable.html#aa742e95c087b0340bcff458b8872e2ea" title="Get the combined transform of the object. ">gf::Transformable::getTransform()</a>).</p>
<h2><a class="anchor" id="shader_default_fragment_shader"></a>
Default fragment shader</h2>
<p>Here is the default fragment shader:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#version 100</span></div><div class="line"></div><div class="line">precision mediump float;</div><div class="line"></div><div class="line"><span class="comment">// The inputs from the vertex shader</span></div><div class="line"><span class="comment">// - color of the vertex</span></div><div class="line"><span class="comment">// - texture coordinates</span></div><div class="line"></div><div class="line">varying vec4 v_color;</div><div class="line">varying vec2 v_texCoords;</div><div class="line"></div><div class="line"><span class="comment">// The texture used for the object</span></div><div class="line"><span class="comment">// It is a constant (uniform) accross all vertices.</span></div><div class="line"></div><div class="line">uniform sampler2D u_texture;</div><div class="line"></div><div class="line"><span class="comment">// The main program starts here.</span></div><div class="line"></div><div class="line"><span class="keywordtype">void</span> main(<span class="keywordtype">void</span>) {</div><div class="line"></div><div class="line">  <span class="comment">// Compute the color from the texture and texture coordinates</span></div><div class="line"></div><div class="line">  vec4 color = texture2D(u_texture, v_texCoords);</div><div class="line"></div><div class="line">  <span class="comment">// Compute the final color by multiplying with the color of the object</span></div><div class="line"></div><div class="line">  gl_FragColor = color * v_color;</div><div class="line">}</div></div><!-- fragment --><p>The <code>u_texture</code> constant is set by the library automatically. If no texture is provided, a default opaque white infinite texture is set.</p>
<p>Quite easy. We are in 2D!</p>
<h1><a class="anchor" id="shader_user_shader"></a>
User provided shader</h1>
<p>If you want to write your own shader, you will have to use the same variables (with the same names) so that you can receive the data from the vertices. The easiest way to do it is to start from the default shaders and modify them. This means you can not add <code>attribute</code> variables, but you can do whatever you want with <code>varying</code> variables and you can add <code>uniform</code> variables as long as you keep the two already present variables <code>u_transform</code> and <code>u_texture</code>.</p>
<p>Then, you can load your shader with <a class="el" href="classgf_1_1_shader.html#a00c2793d2d1973c62d12c1d0b75ada26" title="Load the vertex of fragment shader from a file. ">gf::Shader::loadFromFile()</a> (or any other loading method of <a class="el" href="classgf_1_1_shader.html" title="An OpenGL vertex and/or fragment shader. ">gf::Shader</a>).</p>
<div class="fragment"><div class="line"><a class="code" href="classgf_1_1_shader.html">gf::Shader</a> shader;</div><div class="line">shader.<a class="code" href="classgf_1_1_shader.html#a00c2793d2d1973c62d12c1d0b75ada26">loadFromFile</a>(<span class="stringliteral">&quot;my.vert&quot;</span>, <span class="stringliteral">&quot;my.frag&quot;</span>);</div></div><!-- fragment --><p>If you have additional constants (uniforms), you can set them with one of the <a class="el" href="classgf_1_1_shader.html#ac083437e59677e779e3508e2f0097fbf" title="Specify value for a float uniform. ">gf::Shader::setUniform()</a> functions.</p>
<p>Finally, you can use the <a class="el" href="structgf_1_1_render_states.html" title="Define the states used for drawing to a RenderTarget. ">gf::RenderStates</a> to specify your shader when rendering your objects.</p>
<div class="fragment"><div class="line"><a class="code" href="classgf_1_1_sprite.html">gf::Sprite</a> sprite;</div><div class="line"></div><div class="line"><span class="comment">// ... initialize the sprite</span></div><div class="line"></div><div class="line"><a class="code" href="structgf_1_1_render_states.html">gf::RenderStates</a> states;</div><div class="line">states.<a class="code" href="structgf_1_1_render_states.html#a38b5fe28cff8f7760bbb9904e3a13f11">shader</a> = &amp;shader;</div><div class="line"></div><div class="line">renderer.draw(sprite, states);</div></div><!-- fragment --><h1><a class="anchor" id="shader_post_processing"></a>
Post-processing</h1>
<p>Post-processing is an application of global graphic effects after the frame has been computed. It can be used for a wide range of usage. Technically, the frame is rendered in a texture and the texture is then sent into the graphics pipeline again i.e. in the shaders where you can apply the desired effect.</p>
<p>In gf, there are some already predefined post-processing shaders, called effects:</p>
<ul>
<li><a class="el" href="classgf_1_1_anti_aliasing_effect.html" title="Anti-aliasing effect. ">gf::AntiAliasingEffect</a>: the FXAA anti-aliasing algorithm</li>
<li><a class="el" href="classgf_1_1_color_effect.html" title="Simple color effects. ">gf::ColorEffect</a>: several color transformation (grayscale, sepia, etc)</li>
<li><a class="el" href="classgf_1_1_color_blind_effect.html" title="Simulation of color blindness. ">gf::ColorBlindEffect</a>: a color transformation to simulate color blindness</li>
<li><a class="el" href="classgf_1_1_edge_effect.html" title="Edge detector. ">gf::EdgeEffect</a>: an edge detector to improve the edges</li>
</ul>
<p>You can write your own post-processing effects. Generally, you only use a special fragment shader.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classgf_1_1_post_processing.html" title="A post-processing drawable. ">gf::PostProcessing</a>, <a class="el" href="classgf_1_1_effect.html" title="A post-processing effect. ">gf::Effect</a>, <a class="el" href="classgf_1_1_render_pipeline.html" title="A render pipeline. ">gf::RenderPipeline</a> </dd>
<dd>
<a href="http://www.geeks3d.com/shader-library/#postfx">Shader Library, Post-Processing Filters - Geeks3D</a> </dd>
<dd>
<a href="http://learnopengl.com/#!In-Practice/2D-Game/Postprocessing">Postprocessing - LearnOpenGL.com</a> </dd></dl>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
