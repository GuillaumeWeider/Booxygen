<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- The above 3 meta tags *must* come first in the head; any other head content must come *after* these tags -->
    <meta name="description" content="">
    <meta name="author" content="">

    <title>Booxygen</title>
</head>

<body>

<h1>Booxygen example</h1>
<h2>Index page</h2><br>


<h3>Classes:</h3>

    
        - <compoundname>gf::Action</compoundname><br>
        Brief desc: <para>An action that can be triggered by different controls. </para><br>
        Full desc: <br>

        
            

                <br><strong>Section: </strong>
                <header>Type of the action</header><br>

                
                    - <name>setContinuous</name><br>
                
                    - <name>isContinuous</name><br>
                
                    - <name>setInstantaneous</name><br>
                
                    - <name>isInstantaneous</name><br>
                

            
        
            

                <br><strong>Section: </strong>
                <header>Controls for the action</header><br>

                
                    - <name>addKeycodeKeyControl</name><br>
                
                    - <name>addScancodeKeyControl</name><br>
                
                    - <name>addMouseButtonControl</name><br>
                
                    - <name>addGamepadButtonControl</name><br>
                
                    - <name>addGamepadAxisControl</name><br>
                
                    - <name>addCloseControl</name><br>
                
                    - <name>addControl</name><br>
                

            
        
            

                <br><strong>Section: </strong>
                <header>State of the action</header><br>

                
                    - <name>processEvent</name><br>
                
                    - <name>isActive</name><br>
                
                    - <name>reset</name><br>
                

            
        
            
        
            
        
            
        
        <br>
    

    
        - <compoundname>gf::ActionContainer</compoundname><br>
        Brief desc: <para>A set of actions. </para><br>
        Full desc: <br>

        
            
        
            
        
        <br>
    

    
        - <compoundname>gf::Activity</compoundname><br>
        Brief desc: <para>A game activity. </para><br>
        Full desc: <para>An activity is a task that can be run over time. <computeroutput>gf</computeroutput> provides predefined activites but you can also add your own activities.</para><para>Here is a list of predefined activites:</para><para><itemizedlist>
<listitem><para><ref refid="classgf_1_1_value_activity" kindref="compound">gf::ValueActivity</ref></para></listitem><listitem><para><ref refid="classgf_1_1_rotate_to_activity" kindref="compound">gf::RotateToActivity</ref></para></listitem><listitem><para><ref refid="classgf_1_1_move_to_activity" kindref="compound">gf::MoveToActivity</ref></para></listitem><listitem><para><ref refid="classgf_1_1_color_activity" kindref="compound">gf::ColorActivity</ref></para></listitem><listitem><para><ref refid="classgf_1_1_callback_activity" kindref="compound">gf::CallbackActivity</ref></para></listitem><listitem><para><ref refid="classgf_1_1_delay_activity" kindref="compound">gf::DelayActivity</ref></para></listitem><listitem><para><ref refid="classgf_1_1_sequence_activity" kindref="compound">gf::SequenceActivity</ref></para></listitem><listitem><para><ref refid="classgf_1_1_repeat_activity" kindref="compound">gf::RepeatActivity</ref></para></listitem><listitem><para><ref refid="classgf_1_1_parallel_activity" kindref="compound">gf::ParallelActivity</ref> </para></listitem></itemizedlist>
</para><br>

        
            
        
        <br>
    

    
        - <compoundname>gf::AdaptativeView</compoundname><br>
        Brief desc: <para>Adaptative view. </para><br>
        Full desc: <para>An adaptative view is a view that adapts automatically to screen resolution change.</para><para>There are several kinds of adaptative views, according to the policy that is adopted when the resolution changes. In the examples below, The screen is represented by the black rectangle and the world is the red square. If red dashed lines appears, it means that the world has been modified.</para><para><table rows="7" cols="2"><row>
<entry thead="yes"><para>Class </para></entry><entry thead="yes"><para>Example  </para></entry></row>
<row>
<entry thead="no"><para><ref refid="classgf_1_1_stretch_view" kindref="compound">gf::StretchView</ref> </para></entry><entry thead="no"><para><image type="html" name="stretchview.png"/>
 </para></entry></row>
<row>
<entry thead="no"><para><ref refid="classgf_1_1_fit_view" kindref="compound">gf::FitView</ref> </para></entry><entry thead="no"><para><image type="html" name="fitview.png"/>
 </para></entry></row>
<row>
<entry thead="no"><para><ref refid="classgf_1_1_fill_view" kindref="compound">gf::FillView</ref> </para></entry><entry thead="no"><para><image type="html" name="fillview.png"/>
 </para></entry></row>
<row>
<entry thead="no"><para><ref refid="classgf_1_1_extend_view" kindref="compound">gf::ExtendView</ref> </para></entry><entry thead="no"><para><image type="html" name="extendview.png"/>
 </para></entry></row>
<row>
<entry thead="no"><para><ref refid="classgf_1_1_locked_view" kindref="compound">gf::LockedView</ref> </para></entry><entry thead="no"><para><image type="html" name="lockedview.png"/>
 </para></entry></row>
<row>
<entry thead="no"><para><ref refid="classgf_1_1_screen_view" kindref="compound">gf::ScreenView</ref> </para></entry><entry thead="no"><para><image type="html" name="screenview.png"/>
 </para></entry></row>
</table>
<simplesect kind="see"><para><ref refid="classgf_1_1_view_container" kindref="compound">gf::ViewContainer</ref> </para></simplesect>
</para><br>

        
            
        
        <br>
    

    

    
        - <compoundname>gf::AlphaTexture</compoundname><br>
        Brief desc: <para>A texture with a single alpha channel. </para><br>
        Full desc: <para>This texture is used internally by <ref refid="classgf_1_1_font" kindref="compound">gf::Font</ref> </para><br>

        
            
        
        <br>
    

    
        - <compoundname>gf::AnimatedSprite</compoundname><br>
        Brief desc: <para>An animated sprite. </para><br>
        Full desc: <para>An animated sprite is a sprite that can display an animation.</para><para><simplesect kind="see"><para><ref refid="classgf_1_1_sprite" kindref="compound">gf::Sprite</ref>, <ref refid="classgf_1_1_animation" kindref="compound">gf::Animation</ref> </para></simplesect>
</para><br>

        
            
        
            
        
        <br>
    

    
        - <compoundname>gf::Animation</compoundname><br>
        Brief desc: <para>An animation. </para><br>
        Full desc: <para>An animation is a collection of frames that are displayed consecutively during a predefined amount of time.</para><para>To display an animation, you need a <ref refid="classgf_1_1_animated_sprite" kindref="compound">gf::AnimatedSprite</ref>.</para><para><simplesect kind="see"><para><ref refid="classgf_1_1_animated_sprite" kindref="compound">gf::AnimatedSprite</ref> </para></simplesect>
</para><br>

        
            
        
            
        
        <br>
    

    
        - <compoundname>gf::AntiAliasingEffect</compoundname><br>
        Brief desc: <para>Anti-aliasing effect. </para><br>
        Full desc: <para>This effect uses <ulink url="https://en.wikipedia.org/wiki/Fast_approximate_anti-aliasing">Fast Approximate Anti-Aliasing (FXAA)</ulink>. </para><br>

        
            
        
        <br>
    

    
        - <compoundname>gf::Array2D</compoundname><br>
        Brief desc: <para>A two-dimensional array. </para><br>
        Full desc: <para>gf::Array represents a two-dimensional array, organized in row-major order.</para><para>The array is templated with the type of the data and the type of the indices (defaults to <computeroutput>unsigned</computeroutput>).</para><para>Contrary to the usual way of accessing 2D arrays, the first coordinate is the column and the second coordinate is the row. So that, if <computeroutput>size</computeroutput> is the size of the array and <computeroutput>pos</computeroutput> is the position in the array:</para><para><itemizedlist>
<listitem><para><formula id="1">$ 0 \leq \mathtt{pos.x} = \mathtt{pos.col} &lt; \mathtt{size.width} = \mathtt{size.col} $</formula></para></listitem><listitem><para><formula id="2">$ 0 \leq \mathtt{pos.y} = \mathtt{pos.row} &lt; \mathtt{size.height} = \mathtt{size.row} $</formula></para></listitem></itemizedlist>
</para><para>Some convinient visitors are provided to visit the four neighbors (up, down, left and right), or the eight neighbors.</para><para><simplesect kind="see"><para><ref refid="structgf_1_1_matrix" kindref="compound">gf::Matrix</ref> </para></simplesect>
</para><br>

        
            

                <br><strong>Section: </strong>
                <header>Raw data access</header><br>

                
                    - <name>getDataPtr</name><br>
                
                    - <name>getDataSize</name><br>
                
                    - <name>getSize</name><br>
                
                    - <name>getCols</name><br>
                
                    - <name>getRows</name><br>
                
                    - <name>isEmpty</name><br>
                
                    - <name>isValid</name><br>
                

            
        
            

                <br><strong>Section: </strong>
                <header>Elements access</header><br>

                
                    - <name>operator()</name><br>
                
                    - <name>operator()</name><br>
                
                    - <name>operator()</name><br>
                
                    - <name>operator()</name><br>
                
                    - <name>toPosition</name><br>
                

            
        
            

                <br><strong>Section: </strong>
                <header>Visitors</header><br>

                
                    - <name>visit4Neighbors</name><br>
                
                    - <name>visit4Neighbors</name><br>
                
                    - <name>visit12Neighbors</name><br>
                
                    - <name>visit12Neighbors</name><br>
                
                    - <name>visit8Neighbors</name><br>
                
                    - <name>visit8Neighbors</name><br>
                
                    - <name>visit24Neighbors</name><br>
                
                    - <name>visit24Neighbors</name><br>
                

            
        
            

                <br><strong>Section: </strong>
                <header>Iterators and ranges</header><br>

                
                    - <name>begin</name><br>
                
                    - <name>end</name><br>
                
                    - <name>begin</name><br>
                
                    - <name>end</name><br>
                
                    - <name>getIndexRange</name><br>
                
                    - <name>getRowRange</name><br>
                
                    - <name>getColRange</name><br>
                
                    - <name>getPositionRange</name><br>
                

            
        
            
        
            
        
            
        
        <br>
    

    
        - <compoundname>gf::ArrayRef</compoundname><br>
        Brief desc: <para>A constant reference to an array and its size. </para><br>
        Full desc: <para>This class stores a pointer to some data and its size. It can be built from various inputs: <computeroutput>std::vector</computeroutput>, static array, pointer and size.</para><para><simplesect kind="see"><para><ref refid="classgf_1_1_buffer_ref" kindref="compound">gf::BufferRef</ref>, <ref refid="classgf_1_1_string_ref" kindref="compound">gf::StringRef</ref> </para></simplesect>
</para><br>

        
            
        
            
        
        <br>
    

    
        - <compoundname>gf::AssetManager</compoundname><br>
        Brief desc: <para>An asset manager. </para><br>
        Full desc: <para><ref refid="classgf_1_1_asset_manager" kindref="compound">gf::AssetManager</ref> is a base class for searching files in some seach directories. If you are looking for some more sophisticated manager, you should look at <ref refid="classgf_1_1_resource_manager" kindref="compound">gf::ResourceManager</ref>.</para><para><simplesect kind="see"><para><ref refid="classgf_1_1_resource_manager" kindref="compound">ResourceManager</ref> </para></simplesect>
</para><br>

        
            
        
            
        
        <br>
    

    
        - <compoundname>gf::BareTexture</compoundname><br>
        Brief desc: <para>An image that lives in the graphic memory that can be used for drawing. </para><br>
        Full desc: <para><ref refid="classgf_1_1_bare_texture" kindref="compound">gf::BareTexture</ref> stores pixels that can be drawn, with a sprite for example. A texture lives in the graphics card memory, therefore it is very fast to draw a texture to a render target, or copy a render target to a texture (the graphics card can access both directly).</para><para>Being stored in the graphics card memory has some drawbacks. A texture cannot be manipulated as freely as a <ref refid="classgf_1_1_image" kindref="compound">gf::Image</ref>, you need to prepare the pixels first and then upload them to the texture in a single operation (see <ref refid="classgf_1_1_bare_texture_1aa601abc5feec107d624fba1fe867d484" kindref="member">BareTexture::update()</ref>).</para><para><ref refid="classgf_1_1_bare_texture" kindref="compound">gf::BareTexture</ref> can handle two types of texture:</para><para><itemizedlist>
<listitem><para>colored texture that stores RGBA channels (see <ref refid="classgf_1_1_texture" kindref="compound">gf::Texture</ref>)</para></listitem><listitem><para>alpha texture that stores a single alpha channel (see <ref refid="classgf_1_1_alpha_texture" kindref="compound">gf::AlphaTexture</ref>)</para></listitem></itemizedlist>
</para><para>Generally, you do not manipulate a <ref refid="classgf_1_1_bare_texture" kindref="compound">gf::BareTexture</ref> directly but you can use a <ref refid="classgf_1_1_texture" kindref="compound">gf::Texture</ref>.</para><para><simplesect kind="see"><para><ref refid="classgf_1_1_texture" kindref="compound">gf::Texture</ref>, <ref refid="classgf_1_1_alpha_texture" kindref="compound">gf::AlphaTexture</ref> </para></simplesect>
</para><br>

        
            
        
            
        
            
        
            
        
            
        
        <br>
    

    
        - <compoundname>gf::BetterGradientNoise2D</compoundname><br>
        Brief desc: <para>Better gradient 2D noise. </para><br>
        Full desc: <para>An implementation of the better gradient noise of Kensler et al., especially the new hash function and filter kernel. This noise is slower than gradient noise but gives better results.</para><para><simplesect kind="see"><para><ulink url="https://www.cs.utah.edu/~aek/research/noise.pdf">Better Gradient Noise. A. Kensler, A. Knoll, P. Shirley. 2008</ulink> </para></simplesect>
</para><br>

        
            
        
            
        
            
        
        <br>
    

    
        - <compoundname>gf::BitmapConsoleFont</compoundname><br>
        Brief desc: <para>A bitmap console font. </para><br>
        Full desc: <para>This class is based on <ulink url="http://roguecentral.org/doryen/libtcod/">libtcod</ulink> console font handling. It supports bitmap fonts provided by libtcod.</para><para><simplesect kind="see"><para><ref refid="classgf_1_1_console_font" kindref="compound">gf::ConsoleFont</ref> </para></simplesect>
</para><br>

        
            
        
            
        
        <br>
    

    

    
        - <compoundname>gf::Bresenham</compoundname><br>
        Brief desc: <para>State for the <ref refid="classgf_1_1_bresenham" kindref="compound">Bresenham</ref>'s line algorithm. </para><br>
        Full desc: <para><simplesect kind="see"><para><ref refid="group__core_1ga1ef096f0d24fef43c511b1a384a48e57" kindref="member">gf::generateLine()</ref> </para></simplesect>
<simplesect kind="see"><para><ulink url="https://en.wikipedia.org/wiki/Bresenham%27s_line_algorithm">Bresenham's line algorithm - Wikipedia</ulink> </para></simplesect>
</para><br>

        
            
        
            
        
        <br>
    

    
        - <compoundname>gf::BufferedGeometry</compoundname><br>
        Brief desc: <para>A drawable for buffers. </para><br>
        Full desc: <para>A buffered geometry is a lightweight object to draw vertex buffers. It can handle two vertex buffers, one for the main object and one for the outline when it exists. The outline is drawn first and the main object second.</para><para>In addition to the geometry, a buffered geometry can store a texture if needed because a vertex buffer has no notion of texture.</para><para>Finally, a buffered geometry can remember the local bounds of the original object, so that it can be used for setting an anchor.</para><para><simplesect kind="see"><para><ref refid="classgf_1_1_vertex_buffer" kindref="compound">gf::VertexBuffer</ref> </para></simplesect>
</para><br>

        
            
        
            
        
        <br>
    

    
        - <compoundname>gf::BufferRef</compoundname><br>
        Brief desc: <para>A reference to a modifiable buffer and its size. </para><br>
        Full desc: <para>This class stores a pointer to a buffer and its size. It can be built from various inputs: <computeroutput>std::vector</computeroutput>, <computeroutput>std::array</computeroutput>, static array, pointer and size.</para><para><simplesect kind="see"><para><ref refid="classgf_1_1_array_ref" kindref="compound">gf::ArrayRef</ref>, <ref refid="classgf_1_1_string_ref" kindref="compound">gf::StringRef</ref> </para></simplesect>
</para><br>

        
            
        
            
        
        <br>
    

    
        - <compoundname>gf::CallbackActivity</compoundname><br>
        Brief desc: <para>An activity for calling a function once. </para><br>
        Full desc: <br>

        
            
        
            
        
        <br>
    

    

    

    
        - <compoundname>gf::CircleGeometry</compoundname><br>
        Brief desc: <para>A circle physics geometry. </para><br>
        Full desc: <br>

        
            
        
            
        
        <br>
    

    
        - <compoundname>gf::CircleShape</compoundname><br>
        Brief desc: <para>Specialized shape representing a circle. </para><br>
        Full desc: <para>This class inherits all the functions of <ref refid="classgf_1_1_transformable" kindref="compound">gf::Transformable</ref> (position, rotation, scale, bounds, ...) as well as the functions of <ref refid="classgf_1_1_shape" kindref="compound">gf::Shape</ref> (outline, color, texture, ...).</para><para>Usage example:</para><para>
  <programlisting><codeline><highlight class="normal"><ref refid="classgf_1_1_circle_shape" kindref="compound">gf::CircleShape</ref><sp/>circle;</highlight></codeline>
<codeline><highlight class="normal">circle.<ref refid="classgf_1_1_circle_shape_1af1de36bfe0e2677224e58affb7d5b3c0" kindref="member">setRadius</ref>(150);</highlight></codeline>
<codeline><highlight class="normal">circle.<ref refid="classgf_1_1_shape_1a47e97612eccde5930d2bd5e4569ff5c4" kindref="member">setOutlineColor</ref>(<ref refid="structgf_1_1_color_1a7abeab052065d849d6a3f8b0d9ed57eb" kindref="member">gf::Color::Red</ref>);</highlight></codeline>
<codeline><highlight class="normal">circle.<ref refid="classgf_1_1_shape_1a956e759ca015359dd229abfb12d22b2d" kindref="member">setOutlineThickness</ref>(5);</highlight></codeline>
<codeline><highlight class="normal">circle.<ref refid="classgf_1_1_transformable_1a1110891882093c2e8cbfc839e3300dca" kindref="member">setPosition</ref>({<sp/>10.0f,<sp/>20.0f<sp/>});</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal">window.draw(circle);</highlight></codeline>
</programlisting>
</para><para>Since the graphics card can't draw perfect circles, we have to fake them with multiple triangles connected to each other. The "points count" property of <ref refid="classgf_1_1_circle_shape" kindref="compound">gf::CircleShape</ref> defines how many of these triangles to use, and therefore defines the quality of the circle.</para><para>The number of points can also be used for another purpose; with small numbers you can create any regular polygon shape: equilateral triangle, square, pentagon, hexagon, ...</para><para><simplesect kind="see"><para><ref refid="classgf_1_1_shape" kindref="compound">gf::Shape</ref> </para></simplesect>
</para><br>

        
            
        
            
        
        <br>
    

    
        - <compoundname>gf::Clipboard</compoundname><br>
        Brief desc: <para><ref refid="classgf_1_1_clipboard" kindref="compound">gf::Clipboard</ref> provides an interface for getting and setting the contents of the system clipboard. </para><br>
        Full desc: <para>Usage example: <programlisting><codeline><highlight class="normal">//<sp/>get<sp/>the<sp/>clipboard<sp/>content<sp/>as<sp/>a<sp/>string</highlight></codeline>
<codeline><highlight class="normal">std::string<sp/>string<sp/>=<sp/>gf::Clipboard::getString();</highlight></codeline>
<codeline/>
<codeline><highlight class="normal">//<sp/>or<sp/>use<sp/>it<sp/>in<sp/>the<sp/>event<sp/>loop</highlight></codeline>
<codeline><highlight class="normal">gf::Event<sp/>event;</highlight></codeline>
<codeline/>
<codeline><highlight class="normal">while<sp/>(window.pollEvent(event))<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>if(event.type<sp/>==<sp/>gf::EventType::Closed)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>window.close();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline/>
<codeline><highlight class="normal"><sp/><sp/>if<sp/>(event.type<sp/>==<sp/>gf::EventType::KeyPressed)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>//<sp/>Using<sp/>Ctrl<sp/>+<sp/>V<sp/>to<sp/>paste<sp/>a<sp/>string</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>if<sp/>(event.key.modifiers.test(gf::Mod::Control)<sp/>&amp;&amp;<sp/>event.key.keycode<sp/>==<sp/>gf::Keycode::V)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>string<sp/>=<sp/>gf::Clipboard::getString();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline/>
<codeline><highlight class="normal">//<sp/>set<sp/>the<sp/>clipboard<sp/>to<sp/>a<sp/>string</highlight></codeline>
<codeline><highlight class="normal">gf::Clipboard::setString("Hello<sp/>World!");</highlight></codeline>
</programlisting> </para><br>

        
            
        
        <br>
    

    
        - <compoundname>gf::Clock</compoundname><br>
        Brief desc: <para>Utility class that measures the elapsed time. </para><br>
        Full desc: <para><ref refid="classgf_1_1_clock" kindref="compound">gf::Clock</ref> is a lightweight class for measuring time. It is a thin wrapper around C++11 <ulink url="http://en.cppreference.com/w/cpp/chrono/steady_clock">std::chrono::steady_clock</ulink>.</para><para>Its provides the most precise time that the underlying OS can achieve (generally microseconds or nanoseconds). It also ensures monotonicity, which means that the returned time can never go backward, even if the system time is changed.</para><para>Usage example:</para><para>
  <programlisting><codeline><highlight class="normal"><ref refid="classgf_1_1_clock" kindref="compound">gf::Clock</ref><sp/>clock;</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal">gf::Time<sp/>time1<sp/>=<sp/>clock.<ref refid="classgf_1_1_clock_1a9d7e654bef586f23105f61860367a85c" kindref="member">getElapsedTime</ref>();</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal">gf::Time<sp/>time2<sp/>=<sp/>clock.<ref refid="classgf_1_1_clock_1ad6af1a88379d543468335bece8dd5a1c" kindref="member">restart</ref>();</highlight></codeline>
</programlisting>
</para><para>The <ref refid="classgf_1_1_time" kindref="compound">gf::Time</ref> value returned by the clock can then be converted to a number of seconds, milliseconds or even microseconds.</para><para><simplesect kind="see"><para><ref refid="classgf_1_1_time" kindref="compound">gf::Time</ref> </para></simplesect>
</para><br>

        
            
        
            
        
        <br>
    

    
        - <compoundname>gf::CloseControl</compoundname><br>
        Brief desc: <para>A close control. </para><br>
        Full desc: <br>

        
            
        
        <br>
    

    

    
        - <compoundname>gf::ColorActivity</compoundname><br>
        Brief desc: <para>An activity for a change of color. </para><br>
        Full desc: <para><simplesect kind="see"><para><ref refid="classgf_1_1_tween" kindref="compound">gf::Tween</ref> </para></simplesect>
</para><br>

        
            
        
            
        
        <br>
    

    
        - <compoundname>gf::ColorBlindEffect</compoundname><br>
        Brief desc: <para>Simulation of color blindness. </para><br>
        Full desc: <para><ulink url="https://en.wikipedia.org/wiki/Color_blindness">Color blindness</ulink> is a deficiency of the vision that affects a significant percentage of the population.</para><para>This effect simulate different types of color blindness. </para><br>

        
            
        
            
        
        <br>
    

    

    
        - <compoundname>gf::ColoredConsoleFont</compoundname><br>
        Brief desc: <para>A colored console font. </para><br>
        Full desc: <para>This class handles colored fonts such as the fonts created for <ulink url="http://dwarffortresswiki.org/Tileset_repository">Dwarf Fortress</ulink>. </para><br>

        
            
        
            
        
        <br>
    

    
        - <compoundname>gf::ColorEffect</compoundname><br>
        Brief desc: <para>Simple color effects. </para><br>
        Full desc: <br>

        
            
        
            
        
        <br>
    

    
        - <compoundname>gf::ColorMatrixEffect</compoundname><br>
        Brief desc: <para>Generic color matrix effect. </para><br>
        Full desc: <para>This effect uses a color matrix. You can use it directly or use a subclass that defines their own color matrix for various needs.</para><para><simplesect kind="see"><para><ref refid="classgf_1_1_color_effect" kindref="compound">gf::ColorEffect</ref>, <ref refid="classgf_1_1_color_blind_effect" kindref="compound">gf::ColorBlindEffect</ref> </para></simplesect>
</para><br>

        
            
        
        <br>
    

    

    
        - <compoundname>gf::CompoundCurve</compoundname><br>
        Brief desc: <para>A compound curve. </para><br>
        Full desc: <para>A compound curve is a curve composed of several continuous curves. It is sometimes called a path in vector graphics software. </para><br>

        
            
        
            
        
        <br>
    

    
        - <compoundname>gf::Console</compoundname><br>
        Brief desc: <para>A virtual console. </para><br>
        Full desc: <para>A console is a virtual terminal where you can print the characters from a console font. Each cell of the console has a background color, a foreground color and a 8-bit character.</para><para>A console has a state with default values for different aspects:<itemizedlist>
<listitem><para>a default background color (initiallly <ref refid="structgf_1_1_color_1a88dc1b689ca9dba60a8b7e51de680b4e" kindref="member">gf::Color::Black</ref>)</para></listitem><listitem><para>a default foreground color (initiallly <ref refid="structgf_1_1_color_1aed80fd944d36f831ec5f4c70834df9a4" kindref="member">gf::Color::White</ref>)</para></listitem><listitem><para>a default console effect (initiallly <ref refid="classgf_1_1_console_effect_1aaf7b39fe72da981a92b845f82cddd596a2005f43694b321ba19ce85f841ec61ec" kindref="member">gf::ConsoleEffect::None</ref>)</para></listitem><listitem><para>a default alignment (initiallly <ref refid="group__game_1gga79cfe1ad310880da0b2586645db3af32a945d5e233cf7d6240f6b783b36a374ff" kindref="member">gf::ConsoleAlignment::Left</ref>)</para></listitem></itemizedlist>
</para><para>Several functions use this state to determine actual values.</para><para><simplesect kind="see"><para><ref refid="classgf_1_1_console_font" kindref="compound">gf::ConsoleFont</ref> </para></simplesect>
</para><br>

        
            

                <br><strong>Section: </strong>
                <header>Basic printing</header><br>

                
                    - <name>setDefaultBackground</name><br>
                
                    - <name>getDefaultBackground</name><br>
                
                    - <name>setDefaultForeground</name><br>
                
                    - <name>getDefaultForeground</name><br>
                
                    - <name>clear</name><br>
                
                    - <name>setCharBackground</name><br>
                
                    - <name>getCharBackground</name><br>
                
                    - <name>setCharForeground</name><br>
                
                    - <name>getCharForeground</name><br>
                
                    - <name>setChar</name><br>
                
                    - <name>getChar</name><br>
                
                    - <name>putChar</name><br>
                
                    - <name>putChar</name><br>
                

            
        
            

                <br><strong>Section: </strong>
                <header>String printing</header><br>

                
                    - <name>setDefaultConsoleEffect</name><br>
                
                    - <name>getDefaultConsoleEffect</name><br>
                
                    - <name>setDefaultAlignment</name><br>
                
                    - <name>getDefaultAlignment</name><br>
                
                    - <name>print</name><br>
                
                    - <name>print</name><br>
                
                    - <name>printRect</name><br>
                
                    - <name>printRect</name><br>
                
                    - <name>getHeight</name><br>
                
                    - <name>setColorControl</name><br>
                

            
        
            

                <br><strong>Section: </strong>
                <header>Advanced printing</header><br>

                
                    - <name>drawRectangle</name><br>
                
                    - <name>drawHorizontalLine</name><br>
                
                    - <name>drawVerticalLine</name><br>
                
                    - <name>drawFrame</name><br>
                

            
        
            

                <br><strong>Section: </strong>
                <header>Screen fading</header><br>

                
                    - <name>setFade</name><br>
                
                    - <name>getFadingAmount</name><br>
                
                    - <name>getFadingColor</name><br>
                

            
        
            
        
            
        
            
        
            
        
            
        
            
        
        <br>
    

    

    
        - <compoundname>gf::ConsoleEffect</compoundname><br>
        Brief desc: <para>A console effect on the background color. </para><br>
        Full desc: <para>A console effect is used to modify the background color of the console.</para><para>If <formula id="5">$ \textbf{b} $</formula> is the current background color, and <formula id="6">$ \textbf{c} $</formula> is the wanted color, then the result color <formula id="7">$ \textbf{r} $</formula> is given by the following description. Note that <ref refid="classgf_1_1_console_effect_1aaf7b39fe72da981a92b845f82cddd596af274ec01e4705bf0e491c5265db0e578" kindref="member">ConsoleEffect::AddAlpha</ref> and <ref refid="classgf_1_1_console_effect_1aaf7b39fe72da981a92b845f82cddd596abad4725f1e6c0478a02e144bd67b1a8d" kindref="member">ConsoleEffect::Alpha</ref> need an <formula id="8">$ \alpha $</formula> value.</para><para><simplesect kind="see"><para><ref refid="classgf_1_1_console" kindref="compound">gf::Console</ref> </para></simplesect>
</para><br>

        
            
        
            
        
            
        
        <br>
    

    
        - <compoundname>gf::ConsoleFont</compoundname><br>
        Brief desc: <para>A console font. </para><br>
        Full desc: <para><simplesect kind="see"><para><ref refid="classgf_1_1_console" kindref="compound">gf::Console</ref>, <ref refid="structgf_1_1_console_font_format" kindref="compound">gf::ConsoleFontFormat</ref>, <ref refid="structgf_1_1_console_font_element" kindref="compound">gf::ConsoleFontElement</ref> </para></simplesect>
</para><br>

        
            

                <br><strong>Section: </strong>
                <header>Properties</header><br>

                
                    - <name>getFormat</name><br>
                
                    - <name>getSize</name><br>
                
                    - <name>getCharacterSize</name><br>
                

            
        
            

                <br><strong>Section: </strong>
                <header>Mapping</header><br>

                
                    - <name>mapCode</name><br>
                
                    - <name>mapCodeRange</name><br>
                
                    - <name>mapString</name><br>
                
                    - <name>mapElement</name><br>
                
                    - <name>mapElements</name><br>
                
                    - <name>clearMapping</name><br>
                

            
        
            

                <br><strong>Section: </strong>
                <header>Texture</header><br>

                
                    - <name>getSubTexture</name><br>
                
                    - <name>getTextureRect</name><br>
                
                    - <name>getTexture</name><br>
                

            
        
            
        
            
        
            
        
        <br>
    

    

    

    
        - <compoundname>gf::Control</compoundname><br>
        Brief desc: <para>A physical control. </para><br>
        Full desc: <br>

        
            
        
            
        
        <br>
    

    
        - <compoundname>gf::ConvexShape</compoundname><br>
        Brief desc: <para>Specialized shape representing a convex polygon. </para><br>
        Full desc: <para>This class inherits all the functions of <ref refid="classgf_1_1_transformable" kindref="compound">gf::Transformable</ref> (position, rotation, scale, bounds, ...) as well as the functions of <ref refid="classgf_1_1_shape" kindref="compound">gf::Shape</ref> (outline, color, texture, ...).</para><para>It is important to keep in mind that a convex shape must always be... convex, otherwise it may not be drawn correctly. Moreover, the points must be defined in order; using a random order would result in an incorrect shape.</para><para>Usage example:</para><para>
  <programlisting><codeline><highlight class="normal"><ref refid="classgf_1_1_convex_shape" kindref="compound">gf::ConvexShape</ref><sp/>polygon;</highlight></codeline>
<codeline><highlight class="normal">polygon.<ref refid="classgf_1_1_convex_shape_1abbec645b33fd5f3a78caf0d570d819c0" kindref="member">setPointCount</ref>(3);</highlight></codeline>
<codeline><highlight class="normal">polygon.<ref refid="classgf_1_1_convex_shape_1a86b78d48473b09895abe492b6ade8a0b" kindref="member">setPoint</ref>(0,<sp/>{<sp/><sp/>0.0f,<sp/><sp/>0.0f<sp/>});</highlight></codeline>
<codeline><highlight class="normal">polygon.<ref refid="classgf_1_1_convex_shape_1a86b78d48473b09895abe492b6ade8a0b" kindref="member">setPoint</ref>(1,<sp/>{<sp/><sp/>0.0f,<sp/>10.0f<sp/>});</highlight></codeline>
<codeline><highlight class="normal">polygon.<ref refid="classgf_1_1_convex_shape_1a86b78d48473b09895abe492b6ade8a0b" kindref="member">setPoint</ref>(2,<sp/>{<sp/>25.0f,<sp/><sp/>5.0f<sp/>});</highlight></codeline>
<codeline><highlight class="normal">polygon.<ref refid="classgf_1_1_shape_1a47e97612eccde5930d2bd5e4569ff5c4" kindref="member">setOutlineColor</ref>(<ref refid="structgf_1_1_color_1a7abeab052065d849d6a3f8b0d9ed57eb" kindref="member">gf::Color::Red</ref>);</highlight></codeline>
<codeline><highlight class="normal">polygon.<ref refid="classgf_1_1_shape_1a956e759ca015359dd229abfb12d22b2d" kindref="member">setOutlineThickness</ref>(5);</highlight></codeline>
<codeline><highlight class="normal">polygon.<ref refid="classgf_1_1_transformable_1a1110891882093c2e8cbfc839e3300dca" kindref="member">setPosition</ref>({<sp/>10.0f,<sp/>20.0f<sp/>});</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal">window.draw(polygon);</highlight></codeline>
</programlisting>
</para><para><simplesect kind="see"><para><ref refid="classgf_1_1_shape" kindref="compound">gf::Shape</ref> </para></simplesect>
</para><br>

        
            
        
            
        
        <br>
    

    
        - <compoundname>gf::Coordinates</compoundname><br>
        Brief desc: <para>Helper to compute coordinates in HUD. </para><br>
        Full desc: <br>

        
            
        
            
        
        <br>
    

    
        - <compoundname>gf::CubicBezierCurve</compoundname><br>
        Brief desc: <para>A cubic Bézier curve. </para><br>
        Full desc: <para>A cubic Bézier curve is a Bézier curve with two end points and two control points. </para><br>

        
            
        
            
        
        <br>
    

    
        - <compoundname>gf::Cursor</compoundname><br>
        Brief desc: <para>A mouse cursor. </para><br>
        Full desc: <para>This class abstracts the operating system resources associated with either a native system cursor or a custom cursor.</para><para>After loading the cursor the graphical appearance with either <ref refid="classgf_1_1_cursor_1a44a3417fa273d17e0f4793b2ed437065" kindref="member">loadFromPixels()</ref> or <ref refid="classgf_1_1_cursor_1a7fdcfc6496e98b7efc35c09ba431eeb8" kindref="member">loadFromSystem()</ref>, the cursor can be changed with <ref refid="classgf_1_1_window_1a6bb93be3a77f1fab046201fc3af655d6" kindref="member">gf::Window::setMouseCursor()</ref>.</para><para>The behaviour is undefined if the cursor is destroyed while in use by the window.</para><para>Usage example: <programlisting><codeline><highlight class="normal">gf::Window<sp/>window;</highlight></codeline>
<codeline/>
<codeline><highlight class="normal">//<sp/>...<sp/>create<sp/>window<sp/>as<sp/>usual<sp/>...</highlight></codeline>
<codeline/>
<codeline><highlight class="normal">gf::Cursor<sp/>cursor;</highlight></codeline>
<codeline/>
<codeline><highlight class="normal">if<sp/>(cursor.loadFromSystem(gf::Cursor::Hand))<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>window.setMouseCursor(cursor);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para><para><simplesect kind="see"><para><ref refid="classgf_1_1_window_1a6bb93be3a77f1fab046201fc3af655d6" kindref="member">gf::Window::setMouseCursor()</ref> </para></simplesect>
</para><br>

        
            
        
            
        
            
        
            
        
        <br>
    

    
        - <compoundname>gf::Curve</compoundname><br>
        Brief desc: <para>A curve is a one dimension object. </para><br>
        Full desc: <para>A curve is similar to a shape but for one dimension objects like lines, <ulink url="https://en.wikipedia.org/wiki/B%C3%A9zier_curve">Bézier curves</ulink>, or compound curves.</para><para>A curve can be simple or outlined. A simple curve has no outline and is generally thin. An outline curve is more complex and can have an outline and has no limit on the width. By default, curves are outlined.</para><para><simplesect kind="see"><para><ref refid="classgf_1_1_line" kindref="compound">gf::Line</ref>, <ref refid="classgf_1_1_quadratic_bezier_curve" kindref="compound">gf::QuadraticBezierCurve</ref>, <ref refid="classgf_1_1_cubic_bezier_curve" kindref="compound">gf::CubicBezierCurve</ref>, <ref refid="classgf_1_1_compound_curve" kindref="compound">gf::CompoundCurve</ref> </para></simplesect>
</para><br>

        
            
        
            
        
            
        
            
        
            
        
        <br>
    

    
        - <compoundname>gf::DefaultEffect</compoundname><br>
        Brief desc: <para>Default effect. </para><br>
        Full desc: <para>This post-processing effect does nothing </para><br>

        
            
        
        <br>
    

    
        - <compoundname>gf::DelayActivity</compoundname><br>
        Brief desc: <para>An activity to wait for a predefined duration. </para><br>
        Full desc: <br>

        
            
        
            
        
        <br>
    

    
        - <compoundname>gf::Drawable</compoundname><br>
        Brief desc: <para>Abstract base class for objects that can be drawn to a render window. </para><br>
        Full desc: <para><ref refid="classgf_1_1_drawable" kindref="compound">gf::Drawable</ref> is a very simple base class that allows objects of derived classes to be drawn to a sf::RenderTarget.</para><para>All you have to do in your derived class is to override the <computeroutput><ref refid="classgf_1_1_drawable_1a01535a84e4fb6222311ceb81accc4a27" kindref="member">draw()</ref></computeroutput> virtual function.</para><para>Note that inheriting from <computeroutput><ref refid="classgf_1_1_drawable" kindref="compound">gf::Drawable</ref></computeroutput> is not mandatory, but it allows this nice syntax <computeroutput>target.draw(object)</computeroutput> rather than <computeroutput>object.draw(target)</computeroutput>, which is more consistent with other classes.</para><para>Example:</para><para><programlisting><codeline><highlight class="keyword">class<sp/></highlight><highlight class="normal">MyDrawable<sp/>:<sp/></highlight><highlight class="keyword">public</highlight><highlight class="normal"><sp/><ref refid="classgf_1_1_drawable" kindref="compound">gf::Drawable</ref><sp/>{</highlight></codeline>
<codeline><highlight class="normal"/><highlight class="keyword">public</highlight><highlight class="normal">:</highlight></codeline>
<codeline><highlight class="normal"/></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>...</highlight></codeline>
<codeline><highlight class="normal"/></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">virtual</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/><ref refid="classgf_1_1_drawable_1a01535a84e4fb6222311ceb81accc4a27" kindref="member">draw</ref>(<ref refid="classgf_1_1_render_target" kindref="compound">gf::RenderTarget</ref>&amp;<sp/>target,<sp/><ref refid="structgf_1_1_render_states" kindref="compound">gf::RenderStates</ref><sp/>states)</highlight><highlight class="keyword"><sp/>override<sp/></highlight><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>You<sp/>can<sp/>draw<sp/>other<sp/>high-level<sp/>objects</highlight><highlight class="normal"/></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>target.<ref refid="classgf_1_1_render_target_1a3445880f95c648efbeff3d2572c4c263" kindref="member">draw</ref>(m_sprite,<sp/>states);</highlight></codeline>
<codeline><highlight class="normal"/></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>...<sp/>or<sp/>use<sp/>the<sp/>low-level<sp/>API</highlight><highlight class="normal"/></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>states.<ref refid="structgf_1_1_render_states_1a9e118f46b7e520ad9eb4ea0b9bdbff4d" kindref="member">texture</ref><sp/>=<sp/>&amp;m_texture;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>target.<ref refid="classgf_1_1_render_target_1a3445880f95c648efbeff3d2572c4c263" kindref="member">draw</ref>(m_vertices,<sp/>states);</highlight></codeline>
<codeline><highlight class="normal"/></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"/></codeline>
<codeline><highlight class="normal"/></codeline>
<codeline><highlight class="normal"/><highlight class="keyword">private</highlight><highlight class="normal">:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="classgf_1_1_sprite" kindref="compound">gf::Sprite</ref><sp/>m_sprite;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="classgf_1_1_texture" kindref="compound">gf::Texture</ref><sp/>m_texture;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="classgf_1_1_vertex_array" kindref="compound">gf::VertexArray</ref><sp/>m_vertices;</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
</programlisting> </para><br>

        
            
        
        <br>
    

    
        - <compoundname>gf::Ease</compoundname><br>
        Brief desc: <para>Predefined easing functions. </para><br>
        Full desc: <para>This class defines usual easing functions.</para><para><heading level="1">First set of easing functions</heading>
</para><para>The first set of functions are common interpolation functions.</para><para><itemizedlist>
<listitem><para>linear <formula id="26">\[ f(t) = t \]</formula></para></listitem><listitem><para>smooth <formula id="27">\[ f(t) = -2 * t^3 + 3 * t^2 \]</formula></para></listitem><listitem><para>smoother <formula id="28">\[ f(t) = 6 * t^5 - 15 * t^4 + 10 * t^3 \]</formula></para></listitem></itemizedlist>
</para><para>Here are the plots of these functions:</para><para><table rows="4" cols="2"><row>
<entry thead="yes"><para>Functions </para></entry><entry thead="yes"><para>Plot  </para></entry></row>
<row>
<entry thead="no"><para>linear </para></entry><entry thead="no"><para><image type="html" name="linear.png"/>
  </para></entry></row>
<row>
<entry thead="no"><para>smooth </para></entry><entry thead="no"><para><image type="html" name="smooth.png"/>
  </para></entry></row>
<row>
<entry thead="no"><para>smoother </para></entry><entry thead="no"><para><image type="html" name="smoother.png"/>
  </para></entry></row>
</table>
</para><para><heading level="1">Second set of easing functions</heading>
</para><para><heading level="2">Definitions</heading>
</para><para>The second set are the easing functions defined by Robert Penner. From a base function <formula id="29">$ f(t) $</formula>, four flavors are defined:</para><para><itemizedlist>
<listitem><para>Ease-In: start slow and speed up at the end <formula id="30">\[ \mathtt{easeIn}(t) = f(t) \]</formula></para></listitem><listitem><para>Ease-Out: start fast and slow down at the end <formula id="31">\[ \mathtt{easeOut}(t) = 1 - \mathtt{easeIn}(1 - t) \]</formula></para></listitem><listitem><para>Ease-In-Out: start slow, then speed up in the middle and finally slow down at the end <formula id="32">\[ \mathtt{easeInOut}(t) = \begin{cases} \mathtt{easeIn}(2 \times t) \div 2 &amp; \text{if } t &lt; 0.5 \\ \mathtt{easeOut}(2 \times t + 1) \div 2 + 0.5 &amp; \text{if } t \geq 0.5 \end{cases} \]</formula></para></listitem><listitem><para>Ease-Out-In: start fast, then slow down in the middle and finally speed up at the end <formula id="33">\[ \mathtt{easeOutIn}(t) = \begin{cases} \mathtt{easeOut}(2 \times t) \div 2 &amp; \text{if } t &lt; 0.5 \\ \mathtt{easeIn}(2 \times t + 1) \div 2 + 0.5 &amp; \text{if } t \geq 0.5 \end{cases} \]</formula></para></listitem></itemizedlist>
</para><para><heading level="2">Base functions</heading>
</para><para>Here are the base functions:</para><para><itemizedlist>
<listitem><para>quad <formula id="34">\[ f(t) = t^2 \]</formula></para></listitem><listitem><para>cubic <formula id="35">\[ f(t) = t^3 \]</formula></para></listitem><listitem><para>quart <formula id="36">\[ f(t) = t^4 \]</formula></para></listitem><listitem><para>quint <formula id="37">\[ f(t) = t^5 \]</formula></para></listitem><listitem><para>sine <formula id="38">\[ f(t) = 1 - \cos\left(t \times \frac{\pi}{2}\right)\]</formula></para></listitem><listitem><para>expo <formula id="39">\[ f(t) = \begin{cases} 0 &amp; \text{if } t = 0 \\ 2^{10 \times (t - 1)} &amp; \text{if } t &gt; 0 \end{cases} \]</formula></para></listitem><listitem><para>circ <formula id="40">\[ f(t) = 1 - \sqrt{1 - t^2} \]</formula></para></listitem><listitem><para>back <formula id="41">\[ f(t) = t^2 \times (2.70158 \times t - 1.70158) \]</formula></para></listitem><listitem><para>bounce <formula id="42">\[ f(t) = \begin{cases} 1 - 7.5625 \times (1 - t)^2 &amp; \text{if } 1 - t &lt; 1 / 2.75 \\ 1 - (7.5625 \times (1 - t - 1.5 / 2.75)^2 + 0.75) &amp; \text{if } 1 - t &lt; 2 / 2.75 \\ 1 - (7.5625 \times (1 - t - 2.25 / 2.75)^2 + 0.9375) &amp; \text{if } 1 - t &lt; 2.5 / 2.75 \\ 1 - (7.5625 \times (1 - t - 2.625 / 2.75)^2 + 0.984375) &amp; \text{otherwise} \end{cases} \]</formula></para></listitem><listitem><para>elastic <formula id="43">\[ f(t) = -2^{10 \times (t - 1)} \times \sin\left(\left((t - 1) - \frac{0.3}{4}\right) \times \frac{2 \times \pi}{0.3}\right) \]</formula></para></listitem></itemizedlist>
</para><para><heading level="2">Plots</heading>
</para><para>Here are the plots for all the defined easing functions:</para><para><table rows="11" cols="5"><row>
<entry thead="yes"><para>Function </para></entry><entry thead="yes"><para>Ease-In </para></entry><entry thead="yes"><para>Ease-Out </para></entry><entry thead="yes"><para>Ease-In-Out </para></entry><entry thead="yes"><para>Ease-Out-In  </para></entry></row>
<row>
<entry thead="no"><para>quad </para></entry><entry thead="no"><para><image type="html" name="quadin.png"/>
 </para></entry><entry thead="no"><para><image type="html" name="quadout.png"/>
 </para></entry><entry thead="no"><para><image type="html" name="quadinout.png"/>
 </para></entry><entry thead="no"><para><image type="html" name="quadoutin.png"/>
  </para></entry></row>
<row>
<entry thead="no"><para>cubic </para></entry><entry thead="no"><para><image type="html" name="cubicin.png"/>
 </para></entry><entry thead="no"><para><image type="html" name="cubicout.png"/>
 </para></entry><entry thead="no"><para><image type="html" name="cubicinout.png"/>
 </para></entry><entry thead="no"><para><image type="html" name="cubicoutin.png"/>
  </para></entry></row>
<row>
<entry thead="no"><para>quart </para></entry><entry thead="no"><para><image type="html" name="quartin.png"/>
 </para></entry><entry thead="no"><para><image type="html" name="quartout.png"/>
 </para></entry><entry thead="no"><para><image type="html" name="quartinout.png"/>
 </para></entry><entry thead="no"><para><image type="html" name="quartoutin.png"/>
  </para></entry></row>
<row>
<entry thead="no"><para>quint </para></entry><entry thead="no"><para><image type="html" name="quintin.png"/>
 </para></entry><entry thead="no"><para><image type="html" name="quintout.png"/>
 </para></entry><entry thead="no"><para><image type="html" name="quintinout.png"/>
 </para></entry><entry thead="no"><para><image type="html" name="quintoutin.png"/>
  </para></entry></row>
<row>
<entry thead="no"><para>sine </para></entry><entry thead="no"><para><image type="html" name="sinein.png"/>
 </para></entry><entry thead="no"><para><image type="html" name="sineout.png"/>
 </para></entry><entry thead="no"><para><image type="html" name="sineinout.png"/>
 </para></entry><entry thead="no"><para><image type="html" name="sineoutin.png"/>
  </para></entry></row>
<row>
<entry thead="no"><para>expo </para></entry><entry thead="no"><para><image type="html" name="expoin.png"/>
 </para></entry><entry thead="no"><para><image type="html" name="expoout.png"/>
 </para></entry><entry thead="no"><para><image type="html" name="expoinout.png"/>
 </para></entry><entry thead="no"><para><image type="html" name="expooutin.png"/>
  </para></entry></row>
<row>
<entry thead="no"><para>circ </para></entry><entry thead="no"><para><image type="html" name="circin.png"/>
 </para></entry><entry thead="no"><para><image type="html" name="circout.png"/>
 </para></entry><entry thead="no"><para><image type="html" name="circinout.png"/>
 </para></entry><entry thead="no"><para><image type="html" name="circoutin.png"/>
  </para></entry></row>
<row>
<entry thead="no"><para>back </para></entry><entry thead="no"><para><image type="html" name="backin.png"/>
 </para></entry><entry thead="no"><para><image type="html" name="backout.png"/>
 </para></entry><entry thead="no"><para><image type="html" name="backinout.png"/>
 </para></entry><entry thead="no"><para><image type="html" name="backoutin.png"/>
  </para></entry></row>
<row>
<entry thead="no"><para>bounce </para></entry><entry thead="no"><para><image type="html" name="bouncein.png"/>
 </para></entry><entry thead="no"><para><image type="html" name="bounceout.png"/>
 </para></entry><entry thead="no"><para><image type="html" name="bounceinout.png"/>
 </para></entry><entry thead="no"><para><image type="html" name="bounceoutin.png"/>
  </para></entry></row>
<row>
<entry thead="no"><para>elastic </para></entry><entry thead="no"><para><image type="html" name="elasticin.png"/>
 </para></entry><entry thead="no"><para><image type="html" name="elasticout.png"/>
 </para></entry><entry thead="no"><para><image type="html" name="elasticinout.png"/>
 </para></entry><entry thead="no"><para><image type="html" name="elasticoutin.png"/>
  </para></entry></row>
</table>
</para><para><simplesect kind="see"><para><ref refid="group__core_1ga956e20c5e2e9435c5c40dda37f672f32" kindref="member">gf::Easing</ref> </para></simplesect>
<simplesect kind="see"><para><ulink url="http://robertpenner.com/easing/">Robert Penner's Easing Functions</ulink> </para></simplesect>
<simplesect kind="see"><para><ulink url="http://easings.net/">Easing Functions Cheat Sheet</ulink> </para></simplesect>
</para><br>

        
            
        
            
        
        <br>
    

    
        - <compoundname>gf::EdgeEffect</compoundname><br>
        Brief desc: <para>Edge detector. </para><br>
        Full desc: <para>This effect uses a <ulink url="https://en.wikipedia.org/wiki/Sobel_operator">Sobel filter</ulink>. </para><br>

        
            
        
        <br>
    

    
        - <compoundname>gf::Effect</compoundname><br>
        Brief desc: <para>A post-processing effect. </para><br>
        Full desc: <para><simplesect kind="see"><para><ref refid="classgf_1_1_post_processing" kindref="compound">gf::PostProcessing</ref> </para></simplesect>
</para><br>

        
        <br>
    

    
        - <compoundname>gf::Entity</compoundname><br>
        Brief desc: <para>A game entity. </para><br>
        Full desc: <para><ref refid="classgf_1_1_entity" kindref="compound">gf::Entity</ref> represents a game entity, i.e. an object that is updated and rendered every frame.</para><para>Entities are ordered by priority when they are renderer, with lower priority being rendered first and higher priority being renderered last. The default priority is <formula id="3">$ 0 $</formula>.</para><para>Entities can become dead, in which case they are neither updated nor rendered anymore.</para><para>Entities can be grouped in an <ref refid="classgf_1_1_entity_container" kindref="compound">gf::EntityContainer</ref>.</para><para><simplesect kind="see"><para><ref refid="classgf_1_1_entity_container" kindref="compound">gf::EntityContainer</ref> </para></simplesect>
</para><br>

        
            

                <br><strong>Section: </strong>
                <header>Entity liveness</header><br>

                
                    - <name>isAlive</name><br>
                
                    - <name>setAlive</name><br>
                
                    - <name>kill</name><br>
                

            
        
            
        
            
        
            
        
        <br>
    

    
        - <compoundname>gf::EntityContainer</compoundname><br>
        Brief desc: <para>A collection of entities. </para><br>
        Full desc: <para><ref refid="classgf_1_1_entity_container" kindref="compound">gf::EntityContainer</ref> represents a collection of entities that are updated and rendered automatically. The entity manager takes care of the liveness of the entities and remove the dead entities from the collection.</para><para>The entity manager is <emphasis>not</emphasis> responsible for the memory of the entities. The entities must be allocated by the user and not deleted while they are handled by the entity manager.</para><para>Generally, you only need one entity manager in your game. You create it at the beginning of the game and put all your entities in it. Then you can call <ref refid="classgf_1_1_entity_container_1af1a5d4e626f525b81dfd1d19893f9f8a" kindref="member">gf::EntityContainer::update()</ref> and <ref refid="classgf_1_1_entity_container_1a4095f785ae1f2b90d2c89c25ea1df2d5" kindref="member">gf::EntityContainer::render()</ref> in your game loop.</para><para><simplesect kind="see"><para><ref refid="classgf_1_1_entity" kindref="compound">gf::Entity</ref> </para></simplesect>
</para><br>

        
            

                <br><strong>Section: </strong>
                <header>Entities management</header><br>

                
                    - <name>addEntity</name><br>
                
                    - <name>removeEntity</name><br>
                
                    - <name>removeTypedEntity</name><br>
                

            
        
            
        
            
        
        <br>
    

    

    
        - <compoundname>gf::ExtendView</compoundname><br>
        Brief desc: <para>Extend view. </para><br>
        Full desc: <para>This view keeps the world aspect ratio without black bars by extending the world in one direction. The world is first scaled to fit within the viewport, then the shorter dimension is lengthened to fill the viewport.</para><para><image type="html" name="extendview.png">Extend view</image>
 <simplesect kind="see"><para><ref refid="classgf_1_1_adaptative_view" kindref="compound">gf::AdaptativeView</ref> </para></simplesect>
</para><br>

        
            
        
            
        
            
        
        <br>
    

    
        - <compoundname>gf::FileInputStream</compoundname><br>
        Brief desc: <para>File based input stream. </para><br>
        Full desc: <br>

        
            
        
            
        
        <br>
    

    
        - <compoundname>gf::FillView</compoundname><br>
        Brief desc: <para>Fill view. </para><br>
        Full desc: <para>This view keeps the aspect ratio of the world, but it will always fill the whole screen which might result in parts of the world being cut off.</para><para><image type="html" name="fillview.png">Fill view</image>
 <simplesect kind="see"><para><ref refid="classgf_1_1_adaptative_view" kindref="compound">gf::AdaptativeView</ref> </para></simplesect>
</para><br>

        
            
        
            
        
            
        
        <br>
    

    
        - <compoundname>gf::FitView</compoundname><br>
        Brief desc: <para>Fit view. </para><br>
        Full desc: <para>This view will always maintain the aspect ratio of the world, while scaling it as much as possible to fit the screen. One disadvantage with this strategy is that there may appear black bars.</para><para><image type="html" name="fitview.png">Fit view</image>
 <simplesect kind="see"><para><ref refid="classgf_1_1_adaptative_view" kindref="compound">gf::AdaptativeView</ref> </para></simplesect>
</para><br>

        
            
        
            
        
            
        
        <br>
    

    
        - <compoundname>gf::FixedTimestepModel</compoundname><br>
        Brief desc: <para>Fixed timestep model. </para><br>
        Full desc: <para>This model takes another model that needs a fixed timestep and provides it event if the original timestep is not fixed. This may be useful for physics model, for example. </para><br>

        
            
        
            
        
        <br>
    

    
        - <compoundname>gf::Flags</compoundname><br>
        Brief desc: <para>Bitfield relying on an enumeration. </para><br>
        Full desc: <para>
  <programlisting><codeline><highlight class="normal">enum<sp/>class<sp/>AnimalProperties<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>HasClaws<sp/><sp/><sp/><sp/><sp/>=<sp/>0x01,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>CanFly<sp/><sp/><sp/><sp/><sp/><sp/><sp/>=<sp/>0x02,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>EatsFish<sp/><sp/><sp/><sp/><sp/>=<sp/>0x04,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>IsEndangered<sp/>=<sp/>0x08,</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline/>
<codeline><highlight class="normal">namespace<sp/>gf<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>template&lt;&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>struct<sp/>EnableBitmaskOperators&lt;AnimalProperties&gt;<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>static<sp/>constexpr<sp/>bool<sp/>value<sp/>=<sp/>true;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>};</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline/>
<codeline><highlight class="normal">gf::Flags&lt;AnimalProperties&gt;<sp/>seahawk<sp/>=<sp/>AnimalProperties::CanFly<sp/>|<sp/>AnimalProperties::EatsFish;</highlight></codeline>
<codeline><highlight class="normal">seahawk<sp/>|=<sp/>AnimalProperties::IsEndangered;</highlight></codeline>
<codeline/>
<codeline><highlight class="normal">bool<sp/>b<sp/>=<sp/>seahawk.test(AnimalProperties::HasClaws);<sp/>//<sp/>false</highlight></codeline>
</programlisting>
</para><para>If you do not initialize flags, then the state is undefined. You can use semantic constants <ref refid="group__core_1ga21fb73589fe7966a778a8b77ff9f16b8" kindref="member">gf::All</ref> and <ref refid="group__graphics_1gga5229ccbffec1016d760ddfe296fd2edfa6adf97f83acf6453d4a6a4b1070f3754" kindref="member">gf::None</ref> to set all the flags or none.</para><para><programlisting><codeline><highlight class="normal"><ref refid="classgf_1_1_flags" kindref="compound">gf::Flags&lt;AnimalProperties&gt;</ref><sp/>unicorn(<ref refid="group__core_1ga21fb73589fe7966a778a8b77ff9f16b8" kindref="member">gf::All</ref>);</highlight></codeline>
<codeline><highlight class="normal"/></codeline>
<codeline><highlight class="normal"><ref refid="classgf_1_1_flags" kindref="compound">gf::Flags&lt;AnimalProperties&gt;</ref><sp/>rat(<ref refid="group__graphics_1gga5229ccbffec1016d760ddfe296fd2edfa6adf97f83acf6453d4a6a4b1070f3754" kindref="member">gf::None</ref>);</highlight></codeline>
</programlisting> </para><br>

        
            
        
            
        
            
        
            
        
            
        
        <br>
    

    
        - <compoundname>gf::Font</compoundname><br>
        Brief desc: <para>A character font. </para><br>
        Full desc: <para>Fonts can be loaded from a file, from memory or from a custom stream, and supports the most common types of fonts. See the <computeroutput><ref refid="classgf_1_1_font_1aa7d23688c81a7c31a5667547e1072501" kindref="member">loadFromFile()</ref></computeroutput> function for the complete list of supported formats.</para><para>Once it is loaded, a <ref refid="classgf_1_1_font" kindref="compound">gf::Font</ref> instance provides three types of information about the font:</para><para><itemizedlist>
<listitem><para>Global metrics, such as the line spacing</para></listitem><listitem><para>Per-glyph metrics, such as bounding box or kerning</para></listitem><listitem><para>Pixel representation of glyphs</para></listitem></itemizedlist>
</para><para>Fonts alone are not very useful: they hold the font data but cannot make anything useful of it. To do so you need to use the <ref refid="classgf_1_1_text" kindref="compound">gf::Text</ref> class, which is able to properly output text with several options such as character size, style, color, position, rotation, etc.</para><para>This separation allows more flexibility and better performances: indeed a <ref refid="classgf_1_1_font" kindref="compound">gf::Font</ref> is a heavy resource, and any operation on it is slow (often too slow for real-time applications). On the other side, a <ref refid="classgf_1_1_text" kindref="compound">gf::Text</ref> is a lightweight object which can combine the glyphs data and metrics of a <ref refid="classgf_1_1_font" kindref="compound">gf::Font</ref> to display any text on a render target.</para><para>Note that it is also possible to bind several <ref refid="classgf_1_1_text" kindref="compound">gf::Text</ref> instances to the same <ref refid="classgf_1_1_font" kindref="compound">gf::Font</ref>.</para><para>It is important to note that the <ref refid="classgf_1_1_text" kindref="compound">gf::Text</ref> instance doesn't copy the font that it uses, it only keeps a reference to it. Thus, a <ref refid="classgf_1_1_font" kindref="compound">gf::Font</ref> must not be destructed while it is used by a <ref refid="classgf_1_1_text" kindref="compound">gf::Text</ref> (i.e. never write a function that uses a local <ref refid="classgf_1_1_font" kindref="compound">gf::Font</ref> instance for creating a text).</para><para>Usage example:</para><para>
  <programlisting><codeline><highlight class="comment">//<sp/>Declare<sp/>a<sp/>new<sp/>font</highlight><highlight class="normal"/></codeline>
<codeline><highlight class="normal"><ref refid="classgf_1_1_font" kindref="compound">gf::Font</ref><sp/>font;</highlight></codeline>
<codeline><highlight class="normal"/></codeline>
<codeline><highlight class="normal"/><highlight class="comment">//<sp/>Load<sp/>it<sp/>from<sp/>a<sp/>file</highlight><highlight class="normal"/></codeline>
<codeline><highlight class="normal"/><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!font.<ref refid="classgf_1_1_font_1aa7d23688c81a7c31a5667547e1072501" kindref="member">loadFromFile</ref>(</highlight><highlight class="stringliteral">"arial.ttf"</highlight><highlight class="normal">))</highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>error...</highlight><highlight class="normal"/></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"/></codeline>
<codeline><highlight class="normal"/><highlight class="comment">//<sp/>Create<sp/>a<sp/>text<sp/>which<sp/>uses<sp/>our<sp/>font</highlight><highlight class="normal"/></codeline>
<codeline><highlight class="normal"><ref refid="classgf_1_1_text" kindref="compound">gf::Text</ref><sp/>text1;</highlight></codeline>
<codeline><highlight class="normal">text1.<ref refid="classgf_1_1_text_1a15a7a23bc26f574b29b11f1ea96867bb" kindref="member">setString</ref>(</highlight><highlight class="stringliteral">"Hello<sp/>World!"</highlight><highlight class="normal">)</highlight></codeline>
<codeline><highlight class="normal">text1.<ref refid="classgf_1_1_text_1a744ea0ad425deb12a29f9f58a6738f7b" kindref="member">setFont</ref>(font);</highlight></codeline>
<codeline><highlight class="normal">text1.<ref refid="classgf_1_1_text_1a6672633cb3345b8d0ee61035603710bd" kindref="member">setCharacterSize</ref>(30);</highlight></codeline>
<codeline><highlight class="normal"/></codeline>
<codeline><highlight class="normal"/><highlight class="comment">//<sp/>Create<sp/>another<sp/>text<sp/>using<sp/>the<sp/>same<sp/>font,<sp/>but<sp/>with<sp/>different<sp/>parameters</highlight><highlight class="normal"/></codeline>
<codeline><highlight class="normal"><ref refid="classgf_1_1_text" kindref="compound">gf::Text</ref><sp/>text2;</highlight></codeline>
<codeline><highlight class="normal">text2.<ref refid="classgf_1_1_text_1a15a7a23bc26f574b29b11f1ea96867bb" kindref="member">setString</ref>(</highlight><highlight class="stringliteral">"Goodbye<sp/>world!"</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal">text2.<ref refid="classgf_1_1_text_1a744ea0ad425deb12a29f9f58a6738f7b" kindref="member">setFont</ref>(font);</highlight></codeline>
<codeline><highlight class="normal">text2.<ref refid="classgf_1_1_text_1a6672633cb3345b8d0ee61035603710bd" kindref="member">setCharacterSize</ref>(50);</highlight></codeline>
</programlisting>
</para><para>Apart from loading font files, and passing them to instances of <ref refid="classgf_1_1_text" kindref="compound">gf::Text</ref>, you should normally not have to deal directly with this class. However, it may be useful to access the font metrics or rasterized glyphs for advanced usage. </para><br>

        
            
        
            
        
            
        
        <br>
    

    

    
        - <compoundname>gf::FractalNoise2D</compoundname><br>
        Brief desc: <para>Fractal 2D noise. </para><br>
        Full desc: <para>Fractal noise is based of fractional Brownian motion (fBm). It consists in adding several octaves of a basic noise at different amplitudes. </para><br>

        
            
        
            
        
        <br>
    

    
        - <compoundname>gf::FractalNoise3D</compoundname><br>
        Brief desc: <para>Fractal 3D noise. </para><br>
        Full desc: <para>Fractal noise is based of fractional Brownian motion (fBm). It consists in adding several octaves of a basic noise at different amplitudes. </para><br>

        
            
        
            
        
        <br>
    

    

    
        - <compoundname>gf::Gamepad</compoundname><br>
        Brief desc: <para>Some gamepad related functions. </para><br>
        Full desc: <br>

        
            

                <br><strong>Section: </strong>
                <header>Gamepad management</header><br>

                
                    - <name>open</name><br>
                
                    - <name>isAttached</name><br>
                
                    - <name>close</name><br>
                
                    - <name>getName</name><br>
                

            
        
            
        
            
        
        <br>
    

    
        - <compoundname>gf::GamepadAxisControl</compoundname><br>
        Brief desc: <para>A gamepad axis control. </para><br>
        Full desc: <br>

        
            
        
            
        
        <br>
    

    

    
        - <compoundname>gf::GamepadButtonControl</compoundname><br>
        Brief desc: <para>A gamepad button control. </para><br>
        Full desc: <br>

        
            
        
            
        
        <br>
    

    

    

    

    

    

    
        - <compoundname>gf::GradientNoise2D</compoundname><br>
        Brief desc: <para>Gradient 2D noise. </para><br>
        Full desc: <para><ulink url="https://en.wikipedia.org/wiki/Gradient_noise">Gradient noise</ulink> is a lattice-based noise based on gradients. </para><br>

        
            
        
            
        
            
        
        <br>
    

    
        - <compoundname>gf::GradientNoise3D</compoundname><br>
        Brief desc: <para>Gradient 3D noise. </para><br>
        Full desc: <para><ulink url="https://en.wikipedia.org/wiki/Gradient_noise">Gradient noise</ulink> is a lattice-based noise based on gradients. </para><br>

        
            
        
            
        
            
        
        <br>
    

    
        - <compoundname>gf::GraphicsInfo</compoundname><br>
        Brief desc: <para>A class for graphics info. </para><br>
        Full desc: <para>This class only contains static methods. It provides convenient functions for OpenGL configuration variables. The name of the variables are given in the documentation of the functions.</para><para><simplesect kind="see"><para><ulink url="://docs.gl/es2/glGetString">glGetString() - docs.gl</ulink> </para></simplesect>
<simplesect kind="see"><para><ulink url="http://docs.gl/es2/glGet">glGetIntegerv() - docs.gl</ulink> </para></simplesect>
</para><br>

        
            
        
            
        
        <br>
    

    

    
        - <compoundname>gf::Heightmap</compoundname><br>
        Brief desc: <para>A heightmap. </para><br>
        Full desc: <para><simplesect kind="see"><para><ref refid="group__core_1ga00bbf9120e2ef9f449e55547a0e41324" kindref="member">gf::midpointDisplacement2D()</ref>, <ref refid="group__core_1ga224a9e63967d8b82789bdc3c87797c26" kindref="member">gf::diamondSquare2D()</ref> </para></simplesect>
</para><br>

        
            

                <br><strong>Section: </strong>
                <header>Shaping</header><br>

                
                    - <name>normalize</name><br>
                
                    - <name>addHill</name><br>
                
                    - <name>digHill</name><br>
                
                    - <name>addNoise</name><br>
                
                    - <name>addValue</name><br>
                
                    - <name>scale</name><br>
                
                    - <name>clamp</name><br>
                

            
        
            

                <br><strong>Section: </strong>
                <header>Erosion</header><br>

                
                    - <name>getSlope</name><br>
                
                    - <name>thermalErosion</name><br>
                
                    - <name>hydraulicErosion</name><br>
                
                    - <name>fastErosion</name><br>
                
                    - <name>getErosionScore</name><br>
                

            
        
            

                <br><strong>Section: </strong>
                <header>Export</header><br>

                
                    - <name>subMap</name><br>
                
                    - <name>copyToGrayscaleImage</name><br>
                
                    - <name>copyToColoredImage</name><br>
                

            
        
            
        
            
        
            
        
        <br>
    

    
        - <compoundname>gf::HeteroTerrain2D</compoundname><br>
        Brief desc: <para>Hetero Terrain 2D noise. </para><br>
        Full desc: <br>

        
            
        
            
        
        <br>
    

    
        - <compoundname>gf::HybridMultifractal2D</compoundname><br>
        Brief desc: <para>Hybrid Multifractal 2D noise. </para><br>
        Full desc: <br>

        
            
        
            
        
        <br>
    

    
        - <compoundname>gf::Image</compoundname><br>
        Brief desc: <para>Class for loading, manipulating and saving images. </para><br>
        Full desc: <para><ref refid="classgf_1_1_image" kindref="compound">gf::Image</ref> is an abstraction to manipulate images as bidimensional arrays of pixels. The class provides functions to load, read, write and save pixels, as well as many other useful functions.</para><para><ref refid="classgf_1_1_image" kindref="compound">gf::Image</ref> can handle a unique internal representation of pixels, which is RGBA 32 bits. This means that a pixel must be composed of 8 bits red, green, blue and alpha channels <ndash/> just like a <ref refid="group__core_1ga09c9beb9c818138a42f029091e885e61" kindref="member">gf::Color4u</ref>.</para><para>All the functions that return an array of pixels follow this rule, and all parameters that you pass to <ref refid="classgf_1_1_image" kindref="compound">gf::Image</ref> functions (such as <computeroutput><ref refid="classgf_1_1_image_1ae9465bf351ae989a97de855ab3874701" kindref="member">loadFromMemory()</ref></computeroutput>) must use this representation as well.</para><para>A <ref refid="classgf_1_1_image" kindref="compound">gf::Image</ref> can be copied, but it is a heavy resource and if possible you should always use (const) references to pass or return them to avoid useless copies.</para><para>Usage example:</para><para>
  <programlisting><codeline><highlight class="comment">//<sp/>Load<sp/>an<sp/>image<sp/>file<sp/>from<sp/>a<sp/>file</highlight><highlight class="normal"/></codeline>
<codeline><highlight class="normal"><ref refid="classgf_1_1_image" kindref="compound">gf::Image</ref><sp/>background;</highlight></codeline>
<codeline><highlight class="normal"/></codeline>
<codeline><highlight class="normal"/><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!background.<ref refid="classgf_1_1_image_1a998b74cd7081fad22f368360904623a0" kindref="member">loadFromFile</ref>(</highlight><highlight class="stringliteral">"background.jpg"</highlight><highlight class="normal">))<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>-1;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"/></codeline>
<codeline><highlight class="normal"/><highlight class="comment">//<sp/>Create<sp/>a<sp/>20x20<sp/>image<sp/>filled<sp/>with<sp/>black<sp/>color</highlight><highlight class="normal"/></codeline>
<codeline><highlight class="normal"><ref refid="classgf_1_1_image" kindref="compound">gf::Image</ref><sp/>image;</highlight></codeline>
<codeline><highlight class="normal">image.<ref refid="classgf_1_1_image_1af0e79b68a0ab927f73ff7ee394089fef" kindref="member">create</ref>({<sp/>20,<sp/>20<sp/>},<sp/><ref refid="group__core_1ga09c9beb9c818138a42f029091e885e61" kindref="member">sf::Color4u</ref>{0xFF,<sp/>0xFF,<sp/>0xFF,<sp/>0xFF});</highlight></codeline>
<codeline><highlight class="normal"/></codeline>
<codeline><highlight class="normal"/><highlight class="comment">//<sp/>Make<sp/>the<sp/>top-left<sp/>pixel<sp/>transparent</highlight><highlight class="normal"/></codeline>
<codeline><highlight class="normal"><ref refid="structgf_1_1_vector" kindref="compound">gf::Color4u</ref><sp/>color<sp/>=<sp/>image.<ref refid="classgf_1_1_image_1a4bc5b366661fff559bdf33acedf9f873" kindref="member">getPixel</ref>({<sp/>0,<sp/>0<sp/>});</highlight></codeline>
<codeline><highlight class="normal">color.a<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal">image.<ref refid="classgf_1_1_image_1acc59558cafaef1620c572e91f4289a6b" kindref="member">setPixel</ref>({<sp/>0,<sp/>0<sp/>},<sp/>color);</highlight></codeline>
<codeline><highlight class="normal"/></codeline>
<codeline><highlight class="normal"/><highlight class="comment">//<sp/>Save<sp/>the<sp/>image<sp/>to<sp/>a<sp/>file</highlight><highlight class="normal"/></codeline>
<codeline><highlight class="normal"/><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!image.<ref refid="classgf_1_1_image_1ac1b0df219357a97f6eb7ccb04d4e352a" kindref="member">saveToFile</ref>(</highlight><highlight class="stringliteral">"result.png"</highlight><highlight class="normal">))<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>-1;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting>
</para><para><simplesect kind="see"><para><ref refid="classgf_1_1_texture" kindref="compound">gf::Texture</ref> </para></simplesect>
</para><br>

        
            
        
            
        
        <br>
    

    
        - <compoundname>gf::InputStream</compoundname><br>
        Brief desc: <para>Abstract class for custom file input streams. </para><br>
        Full desc: <para>This class allows users to define their own file input sources from which Gamedev Framework can load resources.</para><para>Gamedev Framework resource classes like <ref refid="classgf_1_1_texture" kindref="compound">gf::Texture</ref> and <ref refid="classgf_1_1_shader" kindref="compound">gf::Shader</ref> provide <computeroutput>loadFromFile()</computeroutput> and <computeroutput>loadFromMemory()</computeroutput> functions, which read data from conventional sources. However, if you have data coming from a different source (over a network, embedded, encrypted, compressed, etc) you can derive your own class from <ref refid="classgf_1_1_input_stream" kindref="compound">gf::InputStream</ref> and load SFML resources with their <computeroutput>loadFromStream()</computeroutput> function. </para><br>

        
            
        
        <br>
    

    

    

    

    
        - <compoundname>gf::KeycodeKeyControl</compoundname><br>
        Brief desc: <para>A key control based on keycode. </para><br>
        Full desc: <br>

        
            
        
            
        
        <br>
    

    

    
        - <compoundname>gf::Library</compoundname><br>
        Brief desc: <para>A class to represent the library. </para><br>
        Full desc: <para>This class is used to initialize the library (especially SDL). Normally, you do not have to care about it if you use a <ref refid="classgf_1_1_window" kindref="compound">gf::Window</ref> or a <ref refid="classgf_1_1_monitor" kindref="compound">gf::Monitor</ref> as the library is automatically initialized with these classes.</para><para>Internally, the class uses reference couting to avoid multiple initializations. </para><br>

        
            
        
            
        
            
        
        <br>
    

    

    
        - <compoundname>gf::Line</compoundname><br>
        Brief desc: <para>A line. </para><br>
        Full desc: <para>A line is a straight curve. It is defined by two end points. </para><br>

        
            
        
            
        
        <br>
    

    

    
        - <compoundname>gf::LockedView</compoundname><br>
        Brief desc: <para>Locked view. </para><br>
        Full desc: <para>This view keeps the world size constant and add black bars if the world is smaller than the screen size or make a zoom in the center of the world if the world is bigger than the screen size.</para><para><image type="html" name="lockedview.png">Locked view</image>
 <simplesect kind="see"><para><ref refid="classgf_1_1_adaptative_view" kindref="compound">gf::AdaptativeView</ref> </para></simplesect>
</para><br>

        
            
        
            
        
            
        
        <br>
    

    
        - <compoundname>gf::Log</compoundname><br>
        Brief desc: <para>Logging functions. </para><br>
        Full desc: <para>Logging functions are used to report some events that have happened in the system. These functions print messages to the standard error. It uses <computeroutput>printf</computeroutput>-like format strings.</para><para>A message is associated to a severity level. The severity level indicates the severity of the message and range from a simple debug message to a fatal message.</para><para>You can set the minimum severity for which messages are displayed. By default, the minimum severity level is gf::Log::Warning (or <ref refid="classgf_1_1_log_1a09dcebe6e9d911a2d9d099115508edf9aee60afc6cba066b732b213601778a367" kindref="member">gf::Log::Debug</ref> if debug mode is activated at build time).</para><para>Example:</para><para><programlisting><codeline><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>entity<sp/>=<sp/>...;</highlight></codeline>
<codeline><highlight class="normal"><ref refid="classgf_1_1_log_1aa4d71938c073d439a4eb35a61fb51f52" kindref="member">gf::Log::warning</ref>(</highlight><highlight class="stringliteral">"Something<sp/>weird<sp/>happened<sp/>to<sp/>entity<sp/>%i!\n"</highlight><highlight class="normal">,<sp/>entity);</highlight></codeline>
</programlisting> </para><br>

        
            
        
            
        
            
        
            
        
            
        
        <br>
    

    
        - <compoundname>gf::Logo</compoundname><br>
        Brief desc: <para>The <computeroutput>gf</computeroutput> logo. </para><br>
        Full desc: <para>This class can show the <computeroutput>gf</computeroutput> logo without loading any font. It is loaded in a texture in the constructor so that you can use it wherever you want.</para><para>If you use <computeroutput>gf</computeroutput> and like it, do not hesitate to show this logo in your game, e.g. on the splash screen. Of course, it is <emphasis>not</emphasis> mandatory. </para><br>

        
            
        
            
        
        <br>
    

    

    

    

    

    
        - <compoundname>gf::MemoryInputStream</compoundname><br>
        Brief desc: <para>Memory based input stream. </para><br>
        Full desc: <br>

        
            
        
            
        
        <br>
    

    

    
        - <compoundname>gf::MessageManager</compoundname><br>
        Brief desc: <para>A message manager. </para><br>
        Full desc: <para>A message manager is responsible for passing messages synchronously between game entities. It relies on a variant of the <ulink url="https://en.wikipedia.org/wiki/Observer_pattern">observer pattern</ulink>. Some entities send messages (subclasses of <ref refid="structgf_1_1_message" kindref="compound">gf::Message</ref> identified by their unique message type) to the message manager while some other entities listen to messages of a defined type through a message handler (<ref refid="group__game_1ga9b1ccf87c23efeaf78584eb75a631bcd" kindref="member">gf::MessageHandler</ref>). As a consequence, there is very low <ulink url="https://en.wikipedia.org/wiki/Coupling_%28computer_programming%29">coupling</ulink> between entities.</para><para>Generally, you only need one message manager in a game. It is a good candidate for being a singleton (thanks to <ref refid="classgf_1_1_singleton" kindref="compound">gf::Singleton</ref>).</para><para>
  <programlisting><codeline><highlight class="normal"><ref refid="classgf_1_1_singleton" kindref="compound">gf::Singleton&lt;gf::MessageManager&gt;</ref><sp/>gMessageManager;</highlight></codeline>
<codeline><highlight class="normal"/></codeline>
<codeline><highlight class="normal"/><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="classgf_1_1_singleton_storage" kindref="compound">gf::SingletonStorage&lt;gf::MessageManager&gt;</ref><sp/>storageForMessageManager(gMessageManager);</highlight></codeline>
<codeline><highlight class="normal"/></codeline>
<codeline><highlight class="normal"><sp/><sp/>gMessageManager().sendMessage(&amp;foo);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting>
</para><para><simplesect kind="see"><para><ref refid="structgf_1_1_message" kindref="compound">gf::Message</ref>, <ref refid="group__game_1ga9b1ccf87c23efeaf78584eb75a631bcd" kindref="member">gf::MessageHandler</ref>, <ref refid="group__core_1ga375ce9d7d861b67c78398d51c1769410" kindref="member">gf::Id</ref> </para></simplesect>
</para><br>

        
            

                <br><strong>Section: </strong>
                <header>Registering an handler</header><br>

                
                    - <name>registerHandler</name><br>
                
                    - <name>registerHandler</name><br>
                
                    - <name>registerHandler</name><br>
                
                    - <name>registerHandler</name><br>
                

            
        
            

                <br><strong>Section: </strong>
                <header>Removing an handler</header><br>

                
                    - <name>removeHandler</name><br>
                
                    - <name>removeHandlers</name><br>
                

            
        
            

                <br><strong>Section: </strong>
                <header>Sending a message</header><br>

                
                    - <name>sendMessage</name><br>
                
                    - <name>sendMessage</name><br>
                

            
        
            
        
            
        
        <br>
    

    
        - <compoundname>gf::Model</compoundname><br>
        Brief desc: <para>A game object that can be updated. </para><br>
        Full desc: <para><ref refid="classgf_1_1_model" kindref="compound">gf::Model</ref> represents a game object that is updated but not rendered. It is simpler than a <ref refid="classgf_1_1_entity" kindref="compound">gf::Entity</ref> because it has no priority and no liveness property.</para><para>It can typically be used to encapsulate a physics engine.</para><para>Models can be grouped in a <ref refid="classgf_1_1_model_container" kindref="compound">gf::ModelContainer</ref>.</para><para><simplesect kind="see"><para><ref refid="classgf_1_1_model_container" kindref="compound">gf::ModelContainer</ref>, <ref refid="classgf_1_1_entity" kindref="compound">gf::Entity</ref> </para></simplesect>
</para><br>

        
            
        
        <br>
    

    
        - <compoundname>gf::ModelContainer</compoundname><br>
        Brief desc: <para>A collection of models. </para><br>
        Full desc: <para><ref refid="classgf_1_1_model_container" kindref="compound">gf::ModelContainer</ref> represents a collection of models that are updated automatically.</para><para>The model manager is <emphasis>not</emphasis> responsible for the memory of the models. The models must be allocated by the user and not deleted while they are handled by the model manager.</para><para>Generally, you only need one model manager in your game. You create it at the beginning of the game and put all your models in it. Then you can call <ref refid="classgf_1_1_model_container_1ab24d704146dc0e331095342b69d6efd6" kindref="member">gf::ModelContainer::update()</ref> in your game loop.</para><para><simplesect kind="see"><para><ref refid="classgf_1_1_model" kindref="compound">gf::Model</ref> </para></simplesect>
</para><br>

        
            
        
            
        
        <br>
    

    
        - <compoundname>gf::Monitor</compoundname><br>
        Brief desc: <para>A monitor. </para><br>
        Full desc: <br>

        
            
        
            
        
            
        
            
        
            
        
        <br>
    

    
        - <compoundname>gf::MouseButtonControl</compoundname><br>
        Brief desc: <para>A mouse button control. </para><br>
        Full desc: <br>

        
            
        
            
        
        <br>
    

    

    

    

    
        - <compoundname>gf::MoveToActivity</compoundname><br>
        Brief desc: <para>An activity for a change of position. </para><br>
        Full desc: <para><simplesect kind="see"><para><ref refid="classgf_1_1_tween" kindref="compound">gf::Tween</ref> </para></simplesect>
</para><br>

        
            
        
            
        
        <br>
    

    
        - <compoundname>gf::Multifractal2D</compoundname><br>
        Brief desc: <para>Multi Fractal 2D noise. </para><br>
        Full desc: <br>

        
            
        
            
        
        <br>
    

    
        - <compoundname>gf::NinePatch</compoundname><br>
        Brief desc: <para>A nine-patch. </para><br>
        Full desc: <para>A nine-patch is a stretchable image that can be automatically resized. You just have to indicate the position of the stretchable area and that's it.</para><para><simplesect kind="see"><para><ulink url="http://developer.android.com/tools/help/draw9patch.html">Android Developers: Draw 9-patch</ulink> </para></simplesect>
<simplesect kind="see"><para><ulink url="http://developer.android.com/guide/topics/graphics/2d-graphics.html#nine-patch">Android Developers: Nine-patch</ulink> </para></simplesect>
</para><br>

        
            
        
            
        
            
        
        <br>
    

    
        - <compoundname>gf::Noise2D</compoundname><br>
        Brief desc: <para>2D A noise function </para><br>
        Full desc: <br>

        
            
        
        <br>
    

    
        - <compoundname>gf::Noise3D</compoundname><br>
        Brief desc: <para>3D A noise function </para><br>
        Full desc: <br>

        
            
        
        <br>
    

    
        - <compoundname>gf::Noise3DTo2DAdapter</compoundname><br>
        Brief desc: <para>An adapter that make a 2D noise from a 3D noise. </para><br>
        Full desc: <para>The 3D point is taken on a plane defined by a normal and a point. The 3D point has the same <formula id="67">$ x $</formula> and <formula id="77">$ y $</formula> coordinates as the 2D point, and the plane is used to determine the <formula id="78">$ z $</formula> coordinate.</para><para>By default, the <formula id="79">$ z = 0 $</formula> plane is used. </para><br>

        
            
        
            
        
        <br>
    

    

    
        - <compoundname>gf::OpenSimplexNoise2D</compoundname><br>
        Brief desc: <para>OpenSimplex 2D noise. </para><br>
        Full desc: <para><ulink url="https://en.wikipedia.org/wiki/OpenSimplex_noise">OpenSimplex noise</ulink> is a lattice noise very similar to simplex noise.</para><para><simplesect kind="see"><para><ref refid="classgf_1_1_simplex_noise2_d" kindref="compound">gf::SimplexNoise2D</ref> </para></simplesect>
</para><br>

        
            
        
            
        
            
        
        <br>
    

    
        - <compoundname>gf::OpenSimplexNoise3D</compoundname><br>
        Brief desc: <para>OpenSimplex3D noise. </para><br>
        Full desc: <para><ulink url="https://en.wikipedia.org/wiki/OpenSimplex_noise">OpenSimplex noise</ulink> is a lattice noise very similar to simplex noise.</para><para><simplesect kind="see"><para>gf::SimplexNoise </para></simplesect>
</para><br>

        
            
        
            
        
            
        
        <br>
    

    

    

    
        - <compoundname>gf::ParallelActivity</compoundname><br>
        Brief desc: <para>An activity to run several activities in parallel. </para><br>
        Full desc: <br>

        
            
        
            
        
            
        
        <br>
    

    

    

    
        - <compoundname>gf::PerlinNoise2D</compoundname><br>
        Brief desc: <para>Perlin 2D noise. </para><br>
        Full desc: <para><ulink url="https://en.wikipedia.org/wiki/Perlin_noise">Perlin noise</ulink> is the combination of a fractal noise and a gradient noise.</para><para><simplesect kind="see"><para><ref refid="classgf_1_1_gradient_noise2_d" kindref="compound">gf::GradientNoise2D</ref>, <ref refid="classgf_1_1_fractal_noise2_d" kindref="compound">gf::FractalNoise2D</ref> </para></simplesect>
</para><br>

        
            
        
            
        
        <br>
    

    
        - <compoundname>gf::PerlinNoise3D</compoundname><br>
        Brief desc: <para>Perlin 3D noise. </para><br>
        Full desc: <para><ulink url="https://en.wikipedia.org/wiki/Perlin_noise">Perlin noise</ulink> is the combination of a fractal noise and a gradient noise.</para><para><simplesect kind="see"><para><ref refid="classgf_1_1_gradient_noise3_d" kindref="compound">gf::GradientNoise3D</ref>, <ref refid="classgf_1_1_fractal_noise3_d" kindref="compound">gf::FractalNoise3D</ref> </para></simplesect>
</para><br>

        
            
        
            
        
        <br>
    

    
        - <compoundname>gf::PhysicsBody</compoundname><br>
        Brief desc: <para>A physics body. </para><br>
        Full desc: <para>A body has several properties:</para><para><itemizedlist>
<listitem><para><ulink url="https://en.wikipedia.org/wiki/Coefficient_of_restitution">restitution</ulink> (default: 0)</para></listitem><listitem><para><ulink url="https://en.wikipedia.org/wiki/Friction#Coefficient_of_friction">static and dynamic friction</ulink> (default: 0)</para></listitem><listitem><para><ulink url="https://en.wikipedia.org/wiki/Damping_ratio">linear damping</ulink> (default: 0)</para></listitem><listitem><para><ulink url="https://en.wikipedia.org/wiki/Density">density</ulink> (default: 1)</para></listitem></itemizedlist>
</para><para><simplesect kind="see"><para><ref refid="classgf_1_1_physics_geometry" kindref="compound">gf::PhysicsGeometry</ref>, <ref refid="classgf_1_1_physics_model" kindref="compound">gf::PhysicsModel</ref> </para></simplesect>
</para><br>

        
            

                <br><strong>Section: </strong>
                <header>Position, angle, velocity and acceleration</header><br>

                
                    - <name>getPosition</name><br>
                
                    - <name>setPosition</name><br>
                
                    - <name>move</name><br>
                
                    - <name>getLinearVelocity</name><br>
                
                    - <name>setLinearVelocity</name><br>
                
                    - <name>applyLinearImpulse</name><br>
                
                    - <name>getAcceleration</name><br>
                
                    - <name>applyForce</name><br>
                
                    - <name>getAngle</name><br>
                
                    - <name>setAngle</name><br>
                
                    - <name>turn</name><br>
                
                    - <name>setVelocityFromAngle</name><br>
                
                    - <name>updateTransform</name><br>
                
                    - <name>getTransform</name><br>
                

            
        
            

                <br><strong>Section: </strong>
                <header>Body properties</header><br>

                
                    - <name>setRestitution</name><br>
                
                    - <name>getRestitution</name><br>
                
                    - <name>setStaticFriction</name><br>
                
                    - <name>getStaticFriction</name><br>
                
                    - <name>setDynamicFriction</name><br>
                
                    - <name>getDynamicFriction</name><br>
                
                    - <name>setLinearDamping</name><br>
                
                    - <name>getLinearDamping</name><br>
                
                    - <name>setDensity</name><br>
                
                    - <name>getInverseMass</name><br>
                

            
        
            
        
            
        
            
        
        <br>
    

    
        - <compoundname>gf::PhysicsGeometry</compoundname><br>
        Brief desc: <para>The geometry of a physics body. </para><br>
        Full desc: <para>The geometry is defined in model coordinates.</para><para><simplesect kind="see"><para><ref refid="classgf_1_1_physics_body" kindref="compound">gf::PhysicsBody</ref> </para></simplesect>
</para><br>

        
            
        
            
        
            
        
        <br>
    

    
        - <compoundname>gf::PhysicsModel</compoundname><br>
        Brief desc: <para>A model for physics simulation. </para><br>
        Full desc: <para><simplesect kind="see"><para><ref refid="classgf_1_1_physics_body" kindref="compound">gf::PhysicsBody</ref>, <ref refid="classgf_1_1_fixed_timestep_model" kindref="compound">gf::FixedTimestepModel</ref> </para></simplesect>
</para><br>

        
            
        
            
        
        <br>
    

    
        - <compoundname>gf::PointParticles</compoundname><br>
        Brief desc: <para>A class to display a high number of points. </para><br>
        Full desc: <br>

        
            
        
            
        
        <br>
    

    
        - <compoundname>gf::Polygon</compoundname><br>
        Brief desc: <para>A convex polygon. </para><br>
        Full desc: <br>

        
            
        
            
        
        <br>
    

    
        - <compoundname>gf::PolygonGeometry</compoundname><br>
        Brief desc: <para>A polygon physics geometry. </para><br>
        Full desc: <para>This geometry includes rectangles. </para><br>

        
            
        
            
        
            
        
        <br>
    

    
        - <compoundname>gf::Polyline</compoundname><br>
        Brief desc: <para>A polyline. </para><br>
        Full desc: <para>A polyline is a set of consecutive segments. It is defined by the points ending the segments. A polyline can be open (chain) or closed (loop). </para><br>

        
            
        
            
        
            
        
        <br>
    

    

    
        - <compoundname>gf::PostProcessing</compoundname><br>
        Brief desc: <para>A post-processing drawable. </para><br>
        Full desc: <para>This class is a light-weight object to apply a post-processing effect to a texture. The texture generally comes froma <ref refid="classgf_1_1_render_texture" kindref="compound">gf::RenderTexture</ref>.</para><para><simplesect kind="see"><para><ref refid="classgf_1_1_render_texture" kindref="compound">gf::RenderTexture</ref> </para></simplesect>
</para><br>

        
            
        
            
        
            
        
        <br>
    

    

    
        - <compoundname>gf::QuadraticBezierCurve</compoundname><br>
        Brief desc: <para>A quadratic Bézier curve. </para><br>
        Full desc: <para>A quadratic Bézier curve is a Bézier curve with two end points and one control point. </para><br>

        
            
        
            
        
        <br>
    

    
        - <compoundname>gf::Queue</compoundname><br>
        Brief desc: <para>A simple concurrent queue. </para><br>
        Full desc: <para>This is a simple concurrent queue that can be used in a multi-threaded application. For example, it can be used between a thread that receives messages from the network and the main loop that handles the messages. </para><br>

        
            
        
            
        
        <br>
    

    
        - <compoundname>gf::Random</compoundname><br>
        Brief desc: <para>A random engine. </para><br>
        Full desc: <para><ref refid="classgf_1_1_random" kindref="compound">gf::Random</ref> is a wrapper around <ulink url="http://en.cppreference.com/w/cpp/numeric/random">C++11 standard random features</ulink>. It embeds a Mersenne Twister engine and provides several distributions above this engine. </para><br>

        
            
        
            
        
        <br>
    

    

    

    
        - <compoundname>gf::RectangleShape</compoundname><br>
        Brief desc: <para>Specialized shape representing a rectangle. </para><br>
        Full desc: <para>This class inherits all the functions of <ref refid="classgf_1_1_transformable" kindref="compound">gf::Transformable</ref> (position, rotation, scale, bounds, ...) as well as the functions of <ref refid="classgf_1_1_shape" kindref="compound">gf::Shape</ref> (outline, color, texture, ...).</para><para>Usage example:</para><para>
  <programlisting><codeline><highlight class="normal"><ref refid="classgf_1_1_rectangle_shape" kindref="compound">gf::RectangleShape</ref><sp/>rectangle;</highlight></codeline>
<codeline><highlight class="normal">rectangle.<ref refid="classgf_1_1_rectangle_shape_1a1d3afff3aeae9d24aa1eb6b7e33141e7" kindref="member">setSize</ref>({<sp/>100.0f,<sp/>50.0f<sp/>});</highlight></codeline>
<codeline><highlight class="normal">rectangle.<ref refid="classgf_1_1_shape_1a47e97612eccde5930d2bd5e4569ff5c4" kindref="member">setOutlineColor</ref>(<ref refid="structgf_1_1_color_1a7abeab052065d849d6a3f8b0d9ed57eb" kindref="member">gf::Color::Red</ref>);</highlight></codeline>
<codeline><highlight class="normal">rectangle.<ref refid="classgf_1_1_shape_1a956e759ca015359dd229abfb12d22b2d" kindref="member">setOutlineThickness</ref>(5);</highlight></codeline>
<codeline><highlight class="normal">rectangle.<ref refid="classgf_1_1_transformable_1a1110891882093c2e8cbfc839e3300dca" kindref="member">setPosition</ref>({<sp/>10.0f,<sp/>20.0f<sp/>});</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal">window.draw(rectangle);</highlight></codeline>
</programlisting>
</para><para><simplesect kind="see"><para><ref refid="classgf_1_1_shape" kindref="compound">gf::Shape</ref> </para></simplesect>
</para><br>

        
            
        
            
        
        <br>
    

    

    
        - <compoundname>gf::RenderPipeline</compoundname><br>
        Brief desc: <para>A render pipeline. </para><br>
        Full desc: <para>A render pipeline automates the application of post-processing effects. A good way to use this class is to make a subclass with all the effects you want to add.</para><para>
  <programlisting><codeline><highlight class="keyword">class<sp/></highlight><highlight class="normal">MyPipeline<sp/>:<sp/></highlight><highlight class="keyword">public</highlight><highlight class="normal"><sp/><ref refid="classgf_1_1_render_pipeline" kindref="compound">gf::RenderPipeline</ref><sp/>{</highlight></codeline>
<codeline><highlight class="normal"/><highlight class="keyword">public</highlight><highlight class="normal">:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MyPipeline(<ref refid="classgf_1_1_window" kindref="compound">gf::Window</ref>&amp;<sp/>window)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>:<sp/><ref refid="namespacegf" kindref="compound">gf</ref>::<ref refid="classgf_1_1_render_pipeline_1ae9dc847f0d2816749dde75ac11f929f5" kindref="member">RenderPipeline</ref>(window)</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="classgf_1_1_render_pipeline_1a78ae4a62017576086edd9fcba4103911" kindref="member">addEffect</ref>(m_effect);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="classgf_1_1_render_pipeline_1a78ae4a62017576086edd9fcba4103911" kindref="member">addEffect</ref>(m_other);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"/></codeline>
<codeline><highlight class="normal"/><highlight class="keyword">protected</highlight><highlight class="normal">:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">virtual</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/><ref refid="classgf_1_1_render_pipeline_1af38d6124884c232c4c6462b389190ce2" kindref="member">onFramebufferResize</ref>(<ref refid="group__core_1gaccbebb53cb8f06205d648e713ec5d40d" kindref="member">Vector2u</ref><sp/>size)</highlight><highlight class="keyword"><sp/>override<sp/></highlight><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>update<sp/>effects<sp/>with<sp/>size</highlight><highlight class="normal"/></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"/></codeline>
<codeline><highlight class="normal"/><highlight class="keyword">private</highlight><highlight class="normal">:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MyEffect<sp/>m_effect;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MyOtherEffect<sp/>m_other;</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
</programlisting>
</para><para><simplesect kind="see"><para><ref refid="classgf_1_1_effect" kindref="compound">gf::Effect</ref> </para></simplesect>
</para><br>

        
            
        
            
        
            
        
        <br>
    

    

    
        - <compoundname>gf::RenderTarget</compoundname><br>
        Brief desc: <para>Base class for all render targets (window, texture, ...) </para><br>
        Full desc: <para><ref refid="classgf_1_1_render_target" kindref="compound">gf::RenderTarget</ref> defines the common behavior of all the 2D render targets usable in the graphics module. It makes it possible to draw 2D entities like sprites, shapes, text without using any OpenGL command directly.</para><para>A <ref refid="classgf_1_1_render_target" kindref="compound">gf::RenderTarget</ref> is also able to use views (<ref refid="classgf_1_1_view" kindref="compound">gf::View</ref>), which are a kind of 2D cameras. With views you can globally scroll, rotate or zoom everything that is drawn, without having to transform every single entity. See the documentation of <ref refid="classgf_1_1_view" kindref="compound">gf::View</ref> for more details and sample pieces of code about this class.</para><para><simplesect kind="see"><para><ref refid="classgf_1_1_render_window" kindref="compound">gf::RenderWindow</ref>, <ref refid="classgf_1_1_render_texture" kindref="compound">gf::RenderTexture</ref>, <ref refid="classgf_1_1_view" kindref="compound">gf::View</ref> </para></simplesect>
</para><br>

        
            

                <br><strong>Section: </strong>
                <header>Drawing commands</header><br>

                
                    - <name>getCanonicalScissorBox</name><br>
                
                    - <name>setCanonicalScissorBox</name><br>
                
                    - <name>getScissorBox</name><br>
                
                    - <name>setScissorBox</name><br>
                
                    - <name>clear</name><br>
                
                    - <name>clear</name><br>
                
                    - <name>getAliasedLineWidthRange</name><br>
                
                    - <name>getLineWidth</name><br>
                
                    - <name>draw</name><br>
                
                    - <name>draw</name><br>
                
                    - <name>draw</name><br>
                
                    - <name>draw</name><br>
                
                    - <name>draw</name><br>
                
                    - <name>draw</name><br>
                

            
        
            

                <br><strong>Section: </strong>
                <header>View management</header><br>

                
                    - <name>setView</name><br>
                
                    - <name>getView</name><br>
                
                    - <name>getCanonicalViewport</name><br>
                
                    - <name>getViewport</name><br>
                
                    - <name>mapPixelToCoords</name><br>
                
                    - <name>mapPixelToCoords</name><br>
                
                    - <name>mapCoordsToPixel</name><br>
                
                    - <name>mapCoordsToPixel</name><br>
                

            
        
            
        
            
        
            
        
            
        
        <br>
    

    
        - <compoundname>gf::RenderTexture</compoundname><br>
        Brief desc: <para>Target for off-screen 2D rendering into a texture. </para><br>
        Full desc: <para><ref refid="classgf_1_1_render_texture" kindref="compound">gf::RenderTexture</ref> is the little brother of <ref refid="classgf_1_1_render_window" kindref="compound">gf::RenderWindow</ref>. It implements the same 2D drawing and OpenGL-related functions (see their base class <ref refid="classgf_1_1_render_target" kindref="compound">gf::RenderTarget</ref> for more details), the difference is that the result is stored in an off-screen texture rather than being show in a window.</para><para>Rendering to a texture can be useful in a variety of situations:</para><para><itemizedlist>
<listitem><para>precomputing a complex static texture (like a level's background from multiple tiles)</para></listitem><listitem><para>applying post-effects to the whole scene with shaders (See <ref refid="classgf_1_1_post_processing" kindref="compound">gf::PostProcessing</ref>)</para></listitem><listitem><para>creating a sprite from a 3D object rendered with OpenGL</para></listitem><listitem><para>etc.</para></listitem></itemizedlist>
</para><para>Usage example:</para><para>
  <programlisting><codeline><highlight class="comment">//<sp/>Create<sp/>a<sp/>new<sp/>render-window</highlight><highlight class="normal"/></codeline>
<codeline><highlight class="normal"><ref refid="classgf_1_1_render_window" kindref="compound">gf::RenderWindow</ref><sp/>renderer(window);</highlight></codeline>
<codeline><highlight class="normal"/></codeline>
<codeline><highlight class="normal"/><highlight class="comment">//<sp/>Create<sp/>a<sp/>new<sp/>render-texture</highlight><highlight class="normal"/></codeline>
<codeline><highlight class="normal"><ref refid="classgf_1_1_render_texture" kindref="compound">gf::RenderTexture</ref><sp/>textureRenderer;</highlight></codeline>
<codeline><highlight class="normal"/></codeline>
<codeline><highlight class="normal"/><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!textureRenderer.<ref refid="classgf_1_1_render_texture_1a93718fcf938abe72ef734f592d2e9a8b" kindref="member">create</ref>(500,<sp/>500))<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>-1;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"/></codeline>
<codeline><highlight class="normal"/><highlight class="comment">//<sp/>The<sp/>main<sp/>loop</highlight><highlight class="normal"/></codeline>
<codeline><highlight class="normal"/><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(window.<ref refid="classgf_1_1_window_1af0d0f974e8edfd10db47fc8040a5874f" kindref="member">isOpen</ref>())<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Event<sp/>processing</highlight><highlight class="normal"/></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>...</highlight><highlight class="normal"/></codeline>
<codeline><highlight class="normal"/></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Activate<sp/>the<sp/>texture</highlight><highlight class="normal"/></codeline>
<codeline><highlight class="normal"><sp/><sp/>textureRenderer.<ref refid="classgf_1_1_render_texture_1a9adac598a52ab54707959baf09bd4ed2" kindref="member">setActive</ref>();</highlight></codeline>
<codeline><highlight class="normal"/></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Clear<sp/>the<sp/>whole<sp/>texture<sp/>with<sp/>red<sp/>color</highlight><highlight class="normal"/></codeline>
<codeline><highlight class="normal"><sp/><sp/>textureRenderer.<ref refid="classgf_1_1_render_target_1a2c3f888d184e81d8668b6ec5b1d332de" kindref="member">clear</ref>(<ref refid="structgf_1_1_color_1a7abeab052065d849d6a3f8b0d9ed57eb" kindref="member">gf::Color::Red</ref>);</highlight></codeline>
<codeline><highlight class="normal"/></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Draw<sp/>stuff<sp/>to<sp/>the<sp/>texture</highlight><highlight class="normal"/></codeline>
<codeline><highlight class="normal"><sp/><sp/>textureRenderer.<ref refid="classgf_1_1_render_target_1a3445880f95c648efbeff3d2572c4c263" kindref="member">draw</ref>(sprite);<sp/><sp/></highlight><highlight class="comment">//<sp/>sprite<sp/>is<sp/>a<sp/>gf::Sprite</highlight><highlight class="normal"/></codeline>
<codeline><highlight class="normal"><sp/><sp/>textureRenderer.<ref refid="classgf_1_1_render_target_1a3445880f95c648efbeff3d2572c4c263" kindref="member">draw</ref>(shape);<sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>shape<sp/>is<sp/>a<sp/>gf::Shape</highlight><highlight class="normal"/></codeline>
<codeline><highlight class="normal"><sp/><sp/>textureRenderer.<ref refid="classgf_1_1_render_target_1a3445880f95c648efbeff3d2572c4c263" kindref="member">draw</ref>(text);<sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>text<sp/>is<sp/>a<sp/>gf::Text</highlight><highlight class="normal"/></codeline>
<codeline><highlight class="normal"/></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>We're<sp/>done<sp/>drawing<sp/>to<sp/>the<sp/>texture</highlight><highlight class="normal"/></codeline>
<codeline><highlight class="normal"><sp/><sp/>textureRenderer.<ref refid="classgf_1_1_render_texture_1ab79514bc3756c73ef7b963bb436b922b" kindref="member">display</ref>();</highlight></codeline>
<codeline><highlight class="normal"/></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Now<sp/>we<sp/>start<sp/>rendering<sp/>to<sp/>the<sp/>window</highlight><highlight class="normal"/></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Activate<sp/>it<sp/>first<sp/>and<sp/>then<sp/>clear<sp/>it</highlight><highlight class="normal"/></codeline>
<codeline><highlight class="normal"><sp/><sp/>renderer.<ref refid="classgf_1_1_render_window_1a371ef7bab8a2957643bdf714c4270b2e" kindref="member">setActive</ref>();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>renderer.<ref refid="classgf_1_1_render_target_1a2c3f888d184e81d8668b6ec5b1d332de" kindref="member">clear</ref>();</highlight></codeline>
<codeline><highlight class="normal"/></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Draw<sp/>the<sp/>texture</highlight><highlight class="normal"/></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="classgf_1_1_sprite" kindref="compound">gf::Sprite</ref><sp/>sprite(textureRenderer.<ref refid="classgf_1_1_render_texture_1a7bfdfa3ecdf12af04994c4573a6925ca" kindref="member">getTexture</ref>());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>renderer.<ref refid="classgf_1_1_render_target_1a3445880f95c648efbeff3d2572c4c263" kindref="member">draw</ref>(sprite);</highlight></codeline>
<codeline><highlight class="normal"/></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>End<sp/>the<sp/>current<sp/>frame<sp/>and<sp/>display<sp/>its<sp/>contents<sp/>on<sp/>screen</highlight><highlight class="normal"/></codeline>
<codeline><highlight class="normal"><sp/><sp/>renderer.<ref refid="classgf_1_1_render_window_1a1d4ad6ad8831957e277a173923ec4720" kindref="member">display</ref>();</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting>
</para><para><simplesect kind="see"><para><ref refid="classgf_1_1_render_target" kindref="compound">gf::RenderTarget</ref>, <ref refid="classgf_1_1_render_window" kindref="compound">gf::RenderWindow</ref>, <ref refid="classgf_1_1_view" kindref="compound">gf::View</ref>, <ref refid="classgf_1_1_texture" kindref="compound">gf::Texture</ref> </para></simplesect>
</para><br>

        
            
        
            
        
        <br>
    

    
        - <compoundname>gf::RenderWindow</compoundname><br>
        Brief desc: <para>A window that can serve as a target for 2D drawing. </para><br>
        Full desc: <para><ref refid="classgf_1_1_render_window" kindref="compound">gf::RenderWindow</ref> is the main class of the graphics module. It defines an OS window that can be painted using the other classes of the graphics module.</para><para>Here is a typical rendering and event loop with a <ref refid="classgf_1_1_render_window" kindref="compound">gf::RenderWindow</ref>:</para><para>
  <programlisting><codeline><highlight class="comment">//<sp/>Declare<sp/>and<sp/>create<sp/>a<sp/>new<sp/>render-window</highlight><highlight class="normal"/></codeline>
<codeline><highlight class="normal"><ref refid="classgf_1_1_window" kindref="compound">gf::Window</ref><sp/>window(</highlight><highlight class="stringliteral">"New<sp/>window"</highlight><highlight class="normal">,<sp/>{<sp/>800,<sp/>600<sp/>});</highlight></codeline>
<codeline><highlight class="normal"><ref refid="classgf_1_1_render_window" kindref="compound">gf::RenderWindow</ref><sp/>renderer(window);</highlight></codeline>
<codeline><highlight class="normal"/></codeline>
<codeline><highlight class="normal"/><highlight class="comment">//<sp/>The<sp/>main<sp/>loop<sp/>-<sp/>ends<sp/>as<sp/>soon<sp/>as<sp/>the<sp/>window<sp/>is<sp/>closed</highlight><highlight class="normal"/></codeline>
<codeline><highlight class="normal"/><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(window.<ref refid="classgf_1_1_window_1af0d0f974e8edfd10db47fc8040a5874f" kindref="member">isOpen</ref>())<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Event<sp/>processing</highlight><highlight class="normal"/></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="structgf_1_1_event" kindref="compound">gf::Event</ref><sp/>event;</highlight></codeline>
<codeline><highlight class="normal"/></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(window.<ref refid="classgf_1_1_window_1a88c202262d1e22f23f164247381deaa6" kindref="member">pollEvent</ref>(event))<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Request<sp/>for<sp/>closing<sp/>the<sp/>window</highlight><highlight class="normal"/></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(event.<ref refid="structgf_1_1_event_1a764707270173af5b617ed6589a58dfe1" kindref="member">type</ref><sp/>==<sp/><ref refid="group__window_1gga244fb10415539f03cde7ed0ae916018da03f4a47830f97377a35321051685071e" kindref="member">gf::EventType::Closed</ref>)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>window.<ref refid="classgf_1_1_window_1a653d8e56d4c27da4aced0dc702edb8a8" kindref="member">close</ref>();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"/></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Clear<sp/>the<sp/>whole<sp/>window<sp/>before<sp/>rendering<sp/>a<sp/>new<sp/>frame</highlight><highlight class="normal"/></codeline>
<codeline><highlight class="normal"><sp/><sp/>renderer.<ref refid="classgf_1_1_render_target_1a2c3f888d184e81d8668b6ec5b1d332de" kindref="member">clear</ref>();</highlight></codeline>
<codeline><highlight class="normal"/></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Draw<sp/>some<sp/>graphical<sp/>entities</highlight><highlight class="normal"/></codeline>
<codeline><highlight class="normal"><sp/><sp/>renderer.<ref refid="classgf_1_1_render_target_1a3445880f95c648efbeff3d2572c4c263" kindref="member">draw</ref>(sprite);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>renderer.<ref refid="classgf_1_1_render_target_1a3445880f95c648efbeff3d2572c4c263" kindref="member">draw</ref>(circle);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>renderer.<ref refid="classgf_1_1_render_target_1a3445880f95c648efbeff3d2572c4c263" kindref="member">draw</ref>(text);</highlight></codeline>
<codeline><highlight class="normal"/></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>End<sp/>the<sp/>current<sp/>frame<sp/>and<sp/>display<sp/>its<sp/>contents<sp/>on<sp/>screen</highlight><highlight class="normal"/></codeline>
<codeline><highlight class="normal"><sp/><sp/>renderer.<ref refid="classgf_1_1_render_window_1a1d4ad6ad8831957e277a173923ec4720" kindref="member">display</ref>();</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting>
</para><para><simplesect kind="see"><para><ref refid="classgf_1_1_window" kindref="compound">gf::Window</ref>, <ref refid="classgf_1_1_render_target" kindref="compound">gf::RenderTarget</ref>, <ref refid="classgf_1_1_render_texture" kindref="compound">gf::RenderTexture</ref>, <ref refid="classgf_1_1_view" kindref="compound">gf::View</ref> </para></simplesect>
</para><br>

        
            
        
            
        
        <br>
    

    
        - <compoundname>gf::RepeatActivity</compoundname><br>
        Brief desc: <para>An activity to run an activity several times. </para><br>
        Full desc: <br>

        
            
        
            
        
        <br>
    

    
        - <compoundname>gf::ResourceCache</compoundname><br>
        Brief desc: <para>A generic cache for resources. </para><br>
        Full desc: <para>This function is a low-level class that is used in <ref refid="classgf_1_1_resource_manager" kindref="compound">gf::ResourceManager</ref>. It is generic enough so that you can use it for your own purpose.</para><para><simplesect kind="see"><para><ref refid="classgf_1_1_resource_manager" kindref="compound">gf::ResourceManager</ref> </para></simplesect>
</para><br>

        
            
        
            
        
            
        
        <br>
    

    
        - <compoundname>gf::ResourceManager</compoundname><br>
        Brief desc: <para>A resource manager. </para><br>
        Full desc: <para><simplesect kind="see"><para><ref refid="classgf_1_1_resource_cache" kindref="compound">gf::ResourceCache</ref> </para></simplesect>
</para><br>

        
            
        
            
        
        <br>
    

    
        - <compoundname>gf::RidgedMultifractal2D</compoundname><br>
        Brief desc: <para>Ridged Multifractal 2D noise. </para><br>
        Full desc: <br>

        
            
        
            
        
        <br>
    

    
        - <compoundname>gf::RotateToActivity</compoundname><br>
        Brief desc: <para>An activity for a change of angle. </para><br>
        Full desc: <para>The activity ensures that the change is no more that <formula id="0">$ \pi $</formula> radians.</para><para><simplesect kind="see"><para><ref refid="classgf_1_1_tween" kindref="compound">gf::Tween</ref> </para></simplesect>
</para><br>

        
            
        
            
        
        <br>
    

    

    
        - <compoundname>gf::RoundedRectangleShape</compoundname><br>
        Brief desc: <para>Specialized shape representing a rounded rectangle. </para><br>
        Full desc: <para>This class inherits all the functions of <ref refid="classgf_1_1_transformable" kindref="compound">gf::Transformable</ref> (position, rotation, scale, bounds, ...) as well as the functions of <ref refid="classgf_1_1_shape" kindref="compound">gf::Shape</ref> (outline, color, texture, ...).</para><para>Usage example:</para><para>
  <programlisting><codeline><highlight class="normal"><ref refid="classgf_1_1_rounded_rectangle_shape" kindref="compound">gf::RoundedRectangleShape</ref><sp/>rectangle;</highlight></codeline>
<codeline><highlight class="normal">rectangle.<ref refid="classgf_1_1_rounded_rectangle_shape_1afc880b9fe7f0da670e48bfac19cc0009" kindref="member">setSize</ref>({<sp/>100.0f,<sp/>50.0f<sp/>});</highlight></codeline>
<codeline><highlight class="normal">rectangle.<ref refid="classgf_1_1_rounded_rectangle_shape_1a8425ce470f94f8a3f265fb2777dbd54c" kindref="member">setRadius</ref>(10);</highlight></codeline>
<codeline><highlight class="normal">rectangle.<ref refid="classgf_1_1_shape_1a47e97612eccde5930d2bd5e4569ff5c4" kindref="member">setOutlineColor</ref>(<ref refid="structgf_1_1_color_1a7abeab052065d849d6a3f8b0d9ed57eb" kindref="member">gf::Color::Red</ref>);</highlight></codeline>
<codeline><highlight class="normal">rectangle.<ref refid="classgf_1_1_shape_1a956e759ca015359dd229abfb12d22b2d" kindref="member">setOutlineThickness</ref>(5);</highlight></codeline>
<codeline><highlight class="normal">rectangle.<ref refid="classgf_1_1_transformable_1a1110891882093c2e8cbfc839e3300dca" kindref="member">setPosition</ref>({<sp/>10.0f,<sp/>20.0f<sp/>});</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal">window.draw(rect);</highlight></codeline>
</programlisting>
</para><para><simplesect kind="see"><para><ref refid="classgf_1_1_shape" kindref="compound">gf::Shape</ref> </para></simplesect>
</para><br>

        
            
        
            
        
        <br>
    

    

    
        - <compoundname>gf::ScancodeKeyControl</compoundname><br>
        Brief desc: <para>A key control based on scancode. </para><br>
        Full desc: <br>

        
            
        
            
        
        <br>
    

    
        - <compoundname>gf::ScreenView</compoundname><br>
        Brief desc: <para>Screen view. </para><br>
        Full desc: <para>This view will always match the window size which means that no scaling happens and no black bars appear. As a disadvantage this means that the gameplay might change, because a player with a bigger screen might see more of the game, than a player with a smaller screen size.</para><para>This view can be used to display <ulink url="https://en.wikipedia.org/wiki/HUD_%28video_gaming%29">HUD</ulink>.</para><para><image type="html" name="screenview.png">Screen view</image>
 <simplesect kind="see"><para><ref refid="classgf_1_1_adaptative_view" kindref="compound">gf::AdaptativeView</ref> </para></simplesect>
</para><br>

        
            
        
            
        
        <br>
    

    
        - <compoundname>gf::SequenceActivity</compoundname><br>
        Brief desc: <para>An activity to run several activities sequentially. </para><br>
        Full desc: <br>

        
            
        
            
        
        <br>
    

    
        - <compoundname>gf::Shader</compoundname><br>
        Brief desc: <para>An OpenGL vertex and/or fragment shader. </para><br>
        Full desc: <para>Shaders are programs written using a specific language, executed directly by the graphics card and allowing to apply real-time operations to the rendered entities.</para><para>There are two kinds of shaders:</para><para><itemizedlist>
<listitem><para>vertex shaders, that process vertices</para></listitem><listitem><para>fragment (or pixel) shaders, that process pixels</para></listitem></itemizedlist>
</para><para>A <ref refid="classgf_1_1_shader" kindref="compound">gf::Shader</ref> can be composed of either a vertex shader alone, a geometry shader alone, a fragment shader alone, or any combination of them. (see the variants of the load functions).</para><para>Shaders are written in GLSL, which is a C-like language dedicated to OpenGL shaders. You'll probably need to learn its basics before writing your own shaders for gf. See also <ref refid="shader" kindref="compound">How to write your own shader</ref>.</para><para>Like any C/C++ program, a GLSL shader has its own variables called <emphasis>uniforms</emphasis> that you can set from your C++ application. <ref refid="classgf_1_1_shader" kindref="compound">gf::Shader</ref> handles different types of uniforms:</para><para><itemizedlist>
<listitem><para>scalars: <computeroutput>float</computeroutput>, <computeroutput>int</computeroutput></para></listitem><listitem><para>vectors (2, 3 or 4 components)</para></listitem><listitem><para>matrices (3x3 or 4x4)</para></listitem><listitem><para>samplers (textures)</para></listitem></itemizedlist>
</para><para>Every uniform variable in a shader can be set through one of the <ref refid="classgf_1_1_shader_1ac083437e59677e779e3508e2f0097fbf" kindref="member">setUniform()</ref> overloads. For example, if you have a shader with the following uniforms:</para><para>
  <programlisting><codeline><highlight class="normal">uniform<sp/>float<sp/>offset;</highlight></codeline>
<codeline><highlight class="normal">uniform<sp/>vec3<sp/>point;</highlight></codeline>
<codeline><highlight class="normal">uniform<sp/>vec4<sp/>color;</highlight></codeline>
<codeline><highlight class="normal">uniform<sp/>mat3<sp/>matrix;</highlight></codeline>
<codeline><highlight class="normal">uniform<sp/>sampler2D<sp/>overlay;</highlight></codeline>
</programlisting>
</para><para>You can set their values from C++ code as follows:</para><para>
  <programlisting><codeline><highlight class="normal">shader.setUniform("offset",<sp/>2.0f);</highlight></codeline>
<codeline><highlight class="normal">shader.setUniform("point",<sp/>gf::Vector3f(0.5f,<sp/>0.8f,<sp/>0.3f));</highlight></codeline>
<codeline><highlight class="normal">shader.setUniform("color",<sp/>color);<sp/>//<sp/>color<sp/>is<sp/>a<sp/>gf::Color4f</highlight></codeline>
<codeline><highlight class="normal">shader.setUniform("matrix",<sp/>trans);<sp/>//<sp/>trans<sp/>is<sp/>a<sp/>gf::Matrix3f</highlight></codeline>
<codeline><highlight class="normal">shader.setUniform("overlay",<sp/>texture);<sp/>//<sp/>texture<sp/>is<sp/>a<sp/>gf::Texture</highlight></codeline>
</programlisting>
</para><para>To apply a shader to a drawable, you must pass it as part of the <ref refid="structgf_1_1_render_states" kindref="compound">gf::RenderStates</ref> in the call to <ref refid="classgf_1_1_render_target_1a3445880f95c648efbeff3d2572c4c263" kindref="member">RenderTarget::draw()</ref> function:</para><para>
  <programlisting><codeline><highlight class="normal"><ref refid="structgf_1_1_render_states" kindref="compound">gf::RenderStates</ref><sp/>states;</highlight></codeline>
<codeline><highlight class="normal">states.<ref refid="structgf_1_1_render_states_1a38b5fe28cff8f7760bbb9904e3a13f11" kindref="member">shader</ref><sp/>=<sp/>&amp;shader;</highlight></codeline>
<codeline><highlight class="normal">renderer.<ref refid="classgf_1_1_render_target_1a3445880f95c648efbeff3d2572c4c263" kindref="member">draw</ref>(sprite,<sp/>states);</highlight></codeline>
</programlisting>
</para><para>In the code above we pass a pointer to the shader, because it may be null (which means "default shader").</para><para>Shaders can be used on any drawable, but some combinations are not interesting. For example, using a vertex shader on a <ref refid="classgf_1_1_sprite" kindref="compound">gf::Sprite</ref> is limited because there are only 4 vertices, the sprite would have to be subdivided in order to apply wave effects. Another bad example is a fragment shader with <ref refid="classgf_1_1_text" kindref="compound">gf::Text</ref>: the texture of the text is not the actual text that you see on screen, it is a big texture containing all the characters of the font in an arbitrary order; thus, texture lookups on pixels other than the current one may not give you the expected result. </para><br>

        
            

                <br><strong>Section: </strong>
                <header>Loading</header><br>

                
                    - <name>loadFromFile</name><br>
                
                    - <name>loadFromFile</name><br>
                
                    - <name>loadFromMemory</name><br>
                
                    - <name>loadFromMemory</name><br>
                
                    - <name>loadFromStream</name><br>
                
                    - <name>loadFromStream</name><br>
                

            
        
            

                <br><strong>Section: </strong>
                <header>Uniform setting</header><br>

                
                    - <name>setUniform</name><br>
                
                    - <name>setUniform</name><br>
                
                    - <name>setUniform</name><br>
                
                    - <name>setUniform</name><br>
                
                    - <name>setUniform</name><br>
                
                    - <name>setUniform</name><br>
                
                    - <name>setUniform</name><br>
                
                    - <name>setUniform</name><br>
                

            
        
            
        
            
        
            
        
            
        
            
        
            
        
        <br>
    

    
        - <compoundname>gf::Shape</compoundname><br>
        Brief desc: <para>Base class for textured shapes with outline. </para><br>
        Full desc: <para><ref refid="classgf_1_1_shape" kindref="compound">gf::Shape</ref> is a drawable class that allows to define and display a custom convex shape on a render target. It's only an abstract base, it needs to be specialized for concrete types of shapes (circle, rectangle, convex polygon, star, ...).</para><para>In addition to the attributes provided by the specialized shape classes, a shape always has the following attributes:</para><para><itemizedlist>
<listitem><para>a texture</para></listitem><listitem><para>a texture rectangle</para></listitem><listitem><para>a fill color</para></listitem><listitem><para>an outline color</para></listitem><listitem><para>an outline thickness</para></listitem></itemizedlist>
</para><para>Each feature is optional, and can be disabled easily:</para><para><itemizedlist>
<listitem><para>the texture can be null</para></listitem><listitem><para>the fill/outline colors can be transparent</para></listitem><listitem><para>the outline thickness can be zero</para></listitem></itemizedlist>
</para><para>You can write your own derived shape class, there are only two virtual functions to override:</para><para><itemizedlist>
<listitem><para><computeroutput><ref refid="classgf_1_1_shape_1a0c5b82272c76f32b7986498f8cc6cbd7" kindref="member">getPointCount()</ref></computeroutput> must return the number of points of the shape</para></listitem><listitem><para><computeroutput><ref refid="classgf_1_1_shape_1a871dc08eece7607815f8c820739156f4" kindref="member">getPoint()</ref></computeroutput> must return the points of the shape</para></listitem></itemizedlist>
</para><para><simplesect kind="see"><para><ref refid="classgf_1_1_rectangle_shape" kindref="compound">gf::RectangleShape</ref>, <ref refid="classgf_1_1_circle_shape" kindref="compound">gf::CircleShape</ref>, <ref refid="classgf_1_1_convex_shape" kindref="compound">gf::ConvexShape</ref> </para></simplesect>
<simplesect kind="see"><para><ref refid="classgf_1_1_transformable" kindref="compound">gf::Transformable</ref> </para></simplesect>
</para><br>

        
            
        
            
        
            
        
            
        
        <br>
    

    
        - <compoundname>gf::ShapeParticles</compoundname><br>
        Brief desc: <para>A class to display a high number of small simple shapes. </para><br>
        Full desc: <br>

        
            
        
            
        
        <br>
    

    
        - <compoundname>gf::SimplexNoise2D</compoundname><br>
        Brief desc: <para>Simplex 2D noise. </para><br>
        Full desc: <para><ulink url="https://en.wikipedia.org/wiki/Simplex_noise">Simplex noise</ulink> is a lattice noise based on gradients put on a simplex.</para><para>This implementation is limited to 2D noise and is <emphasis>not</emphasis> submitted to the patent that covers simplex noise.</para><para><simplesect kind="see"><para><ref refid="classgf_1_1_gradient_noise2_d" kindref="compound">gf::GradientNoise2D</ref> </para></simplesect>
</para><br>

        
            
        
            
        
            
        
        <br>
    

    
        - <compoundname>gf::Singleton</compoundname><br>
        Brief desc: <para>A singleton that wraps a pointer provided by a storage. </para><br>
        Full desc: <para>This class should be used with a global variable. It acts as an access to a singleton which storage is provided by a gf::SingletonStorage&lt;T&gt;.</para><para>
  <programlisting><codeline><highlight class="normal"><ref refid="classgf_1_1_singleton" kindref="compound">gf::Singleton&lt;Foo&gt;</ref><sp/>gFoo;</highlight></codeline>
<codeline><highlight class="normal"/></codeline>
<codeline><highlight class="normal"/><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><ref refid="classgf_1_1_singleton_storage" kindref="compound">gf::SingletonStorage&lt;Foo&gt;</ref><sp/>fooStorage(gFoo);</highlight></codeline>
<codeline><highlight class="normal"/></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>gFoo().bar();</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting>
</para><para><simplesect kind="see"><para><ref refid="classgf_1_1_singleton_storage" kindref="compound">gf::SingletonStorage</ref> </para></simplesect>
</para><br>

        
            
        
            
        
            
        
        <br>
    

    
        - <compoundname>gf::SingletonStorage</compoundname><br>
        Brief desc: <para>A storage for a singleton. </para><br>
        Full desc: <para>This class is a wrapper around an object of class <computeroutput>T</computeroutput> that should be unique in the system. It works in cooperation with a global variable of type gf::Singleton&lt;T&gt;. The global variable is for the access of the object while this class is for the storage of the object. The global variable is initialized at the storage construction.</para><para>
  <programlisting><codeline><highlight class="normal"><ref refid="classgf_1_1_singleton" kindref="compound">gf::Singleton&lt;Foo&gt;</ref><sp/>gFoo;</highlight></codeline>
<codeline><highlight class="normal"/></codeline>
<codeline><highlight class="normal"/><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><ref refid="classgf_1_1_singleton_storage" kindref="compound">gf::SingletonStorage&lt;Foo&gt;</ref><sp/>fooStorage(gFoo);</highlight></codeline>
<codeline><highlight class="normal"/></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/>gFoo().bar();</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting>
</para><para><simplesect kind="see"><para><ref refid="classgf_1_1_singleton" kindref="compound">gf::Singleton</ref> </para></simplesect>
</para><br>

        
            
        
            
        
        <br>
    

    
        - <compoundname>gf::SpaceTree</compoundname><br>
        Brief desc: <para>Binary space random partionning tree. </para><br>
        Full desc: <para>This class implements a random binary space partitioning tree. More precisely, this class is a node in the tree. </para><br>

        
            
        
            
        
            
        
            
        
        <br>
    

    
        - <compoundname>gf::Sprite</compoundname><br>
        Brief desc: <para>A drawable representation of a texture, with its own transformations, color, etc. </para><br>
        Full desc: <para><ref refid="classgf_1_1_sprite" kindref="compound">gf::Sprite</ref> is a drawable class that allows to easily display a texture (or a part of it) on a render target.</para><para>It inherits all the functions from <ref refid="classgf_1_1_transformable" kindref="compound">gf::Transformable</ref>: position, rotation, scale, origin. It also adds sprite-specific properties such as the texture to use, the part of it to display, and some convenience functions to change the overall color of the sprite, or to get its bounding rectangle.</para><para><ref refid="classgf_1_1_sprite" kindref="compound">gf::Sprite</ref> works in combination with the <ref refid="classgf_1_1_texture" kindref="compound">gf::Texture</ref> class, which loads and provides the pixel data of a given texture.</para><para>The separation of <ref refid="classgf_1_1_sprite" kindref="compound">gf::Sprite</ref> and <ref refid="classgf_1_1_texture" kindref="compound">gf::Texture</ref> allows more flexibility and better performances: indeed a <ref refid="classgf_1_1_texture" kindref="compound">gf::Texture</ref> is a heavy resource, and any operation on it is slow (often too slow for real-time applications). On the other side, a <ref refid="classgf_1_1_sprite" kindref="compound">gf::Sprite</ref> is a lightweight object which can use the pixel data of a <ref refid="classgf_1_1_texture" kindref="compound">gf::Texture</ref> and draw it with its own transformation/color/blending attributes.</para><para>It is important to note that the <ref refid="classgf_1_1_sprite" kindref="compound">gf::Sprite</ref> instance doesn't copy the texture that it uses, it only keeps a reference to it. Thus, a <ref refid="classgf_1_1_texture" kindref="compound">gf::Texture</ref> must not be destroyed while it is used by a <ref refid="classgf_1_1_sprite" kindref="compound">gf::Sprite</ref> (i.e. never write a function that uses a local <ref refid="classgf_1_1_texture" kindref="compound">gf::Texture</ref> instance for creating a sprite).</para><para>Usage example: <programlisting><codeline><highlight class="comment">//<sp/>Declare<sp/>and<sp/>load<sp/>a<sp/>texture</highlight><highlight class="normal"/></codeline>
<codeline><highlight class="normal"><ref refid="classgf_1_1_texture" kindref="compound">gf::Texture</ref><sp/>texture;</highlight></codeline>
<codeline><highlight class="normal">texture.<ref refid="classgf_1_1_texture_1a4382398a8c7bcde5a4a2fba892a63ca7" kindref="member">loadFromFile</ref>(</highlight><highlight class="stringliteral">"texture.png"</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"/></codeline>
<codeline><highlight class="normal"/><highlight class="comment">//<sp/>Create<sp/>a<sp/>sprite</highlight><highlight class="normal"/></codeline>
<codeline><highlight class="normal"><ref refid="classgf_1_1_sprite" kindref="compound">gf::Sprite</ref><sp/>sprite;</highlight></codeline>
<codeline><highlight class="normal">sprite.<ref refid="classgf_1_1_sprite_1ac4f384f2bd71d8bbff2a5b4739d523bf" kindref="member">setTexture</ref>(texture);</highlight></codeline>
<codeline><highlight class="normal">sprite.<ref refid="classgf_1_1_sprite_1ad62ac864a6937a8f6b229016b71d7bad" kindref="member">setTextureRect</ref>({<sp/>0.1f,<sp/>0.1f,<sp/>0.5f,<sp/>0.3f<sp/>});</highlight></codeline>
<codeline><highlight class="normal">sprite.<ref refid="classgf_1_1_sprite_1acc83d464d6d81d7962f865fddd91dd7b" kindref="member">setColor</ref>({<sp/>1.0f,<sp/>1.0f,<sp/>1.0f,<sp/>0.8f<sp/>});</highlight></codeline>
<codeline><highlight class="normal">sprite.<ref refid="classgf_1_1_transformable_1a1110891882093c2e8cbfc839e3300dca" kindref="member">setPosition</ref>({<sp/>100.0f,<sp/>25.0f<sp/>});</highlight></codeline>
<codeline><highlight class="normal"/></codeline>
<codeline><highlight class="normal"/><highlight class="comment">//<sp/>Draw<sp/>it</highlight><highlight class="normal"/></codeline>
<codeline><highlight class="normal">renderer.<ref refid="classgf_1_1_render_target_1a3445880f95c648efbeff3d2572c4c263" kindref="member">draw</ref>(sprite);</highlight></codeline>
</programlisting></para><para><simplesect kind="see"><para><ref refid="classgf_1_1_texture" kindref="compound">gf::Texture</ref>, <ref refid="classgf_1_1_transformable" kindref="compound">gf::Transformable</ref>, <ref refid="classgf_1_1_sprite_batch" kindref="compound">gf::SpriteBatch</ref> </para></simplesect>
</para><br>

        
            
        
            
        
            
        
        <br>
    

    
        - <compoundname>gf::SpriteBatch</compoundname><br>
        Brief desc: <para>A sprite batch. </para><br>
        Full desc: <para>A sprite batch is responsible for minimizing the number of draw calls by concatenating the different calls for sprites.</para><para>Before using a sprite batch, you have to call <computeroutput><ref refid="classgf_1_1_sprite_batch_1a25d81a85aa1906e2d6152310e76ed67b" kindref="member">begin()</ref></computeroutput>, then call <computeroutput><ref refid="classgf_1_1_sprite_batch_1ab95640ff5f4193f43e347dfec1441d40" kindref="member">draw()</ref></computeroutput> for each sprite you want to draw, and finally call <computeroutput><ref refid="classgf_1_1_sprite_batch_1abef8f8422d1aa03c52b404331a48370c" kindref="member">end()</ref></computeroutput>.</para><para>
  <programlisting><codeline><highlight class="normal"><ref refid="classgf_1_1_sprite_batch" kindref="compound">gf::SpriteBatch</ref><sp/>batch(renderer);</highlight></codeline>
<codeline><highlight class="normal"/></codeline>
<codeline><highlight class="normal">batch.begin();</highlight></codeline>
<codeline><highlight class="normal">batch.draw(sprite1);</highlight></codeline>
<codeline><highlight class="normal">batch.draw(sprite2);</highlight></codeline>
<codeline><highlight class="normal">batch.draw(sprite3);</highlight></codeline>
<codeline><highlight class="normal">batch.end();</highlight></codeline>
</programlisting>
</para><para><simplesect kind="see"><para><ref refid="classgf_1_1_sprite" kindref="compound">gf::Sprite</ref> </para></simplesect>
</para><br>

        
            
        
            
        
            
        
            
        
        <br>
    

    
        - <compoundname>gf::SpriteParticles</compoundname><br>
        Brief desc: <para>A class to display a high number of sprites. </para><br>
        Full desc: <para><simplesect kind="see"><para><ref refid="classgf_1_1_sprite_batch" kindref="compound">gf::SpriteBatch</ref> </para></simplesect>
</para><br>

        
            
        
            
        
        <br>
    

    
        - <compoundname>gf::SquareGrid</compoundname><br>
        Brief desc: <para>A square grid. </para><br>
        Full desc: <br>

        
            
        
            
        
            
        
        <br>
    

    
        - <compoundname>gf::SquareMap</compoundname><br>
        Brief desc: <para>A square map. </para><br>
        Full desc: <para>A square map is a model of map where cells are organized in a square grid. This type of map is quite common in games. gf provides some useful algorithms related to square maps: field of vision, route finding.</para><para>A cell can be transparent and/or walkable. By default, all cells are neither transparent nor walkable i.e. they are walls. The transparent property of a cell is used to compute the field of vision. The walkable property of a cell is used to compute routes. A cell can be transparent and not walkable (e.g. lava or water), it can be walkable and not transparent (e.g. a secret passage).</para><para><simplesect kind="see"><para><ref refid="group__game_1gad82e9592419fd671caafe4af9b4f89e7" kindref="member">gf::CellProperty</ref> </para></simplesect>
</para><br>

        
            

                <br><strong>Section: </strong>
                <header>Cell properties</header><br>

                
                    - <name>setCell</name><br>
                
                    - <name>clear</name><br>
                
                    - <name>setTransparent</name><br>
                
                    - <name>isTransparent</name><br>
                
                    - <name>setWalkable</name><br>
                
                    - <name>isWalkable</name><br>
                
                    - <name>setEmpty</name><br>
                

            
        
            

                <br><strong>Section: </strong>
                <header>Field of Vision</header><br>

                
                    - <name>clearFieldOfVision</name><br>
                
                    - <name>clearExplored</name><br>
                
                    - <name>computeFieldOfVision</name><br>
                
                    - <name>computeLocalFieldOfVision</name><br>
                
                    - <name>isInFieldOfVision</name><br>
                
                    - <name>isExplored</name><br>
                

            
        
            

                <br><strong>Section: </strong>
                <header>Route</header><br>

                
                    - <name>computeRoute</name><br>
                

            
        
            
        
            
        
        <br>
    

    
        - <compoundname>gf::StarShape</compoundname><br>
        Brief desc: <para>Specialized shape representing a star. </para><br>
        Full desc: <para>This class inherits all the functions of <ref refid="classgf_1_1_transformable" kindref="compound">gf::Transformable</ref> (position, rotation, scale, bounds, ...) as well as the functions of <ref refid="classgf_1_1_shape" kindref="compound">gf::Shape</ref> (outline, color, texture, ...).</para><para>Usage example:</para><para>
  <programlisting><codeline><highlight class="normal"><ref refid="classgf_1_1_star_shape" kindref="compound">gf::StarShape</ref><sp/>star;</highlight></codeline>
<codeline><highlight class="normal">star.<ref refid="classgf_1_1_star_shape_1adae3c207b9c9d7ec7e45c57711aaa119" kindref="member">setMinRadius</ref>(25.0f);</highlight></codeline>
<codeline><highlight class="normal">star.<ref refid="classgf_1_1_star_shape_1ac589a54201231d09a54eb489876f245f" kindref="member">setMaxRadius</ref>(50.0f);</highlight></codeline>
<codeline><highlight class="normal">star.<ref refid="classgf_1_1_star_shape_1aba90fe1a5d938c1b997cbb3d1fb978bf" kindref="member">setBranches</ref>(5);</highlight></codeline>
<codeline><highlight class="normal">star.<ref refid="classgf_1_1_shape_1a47e97612eccde5930d2bd5e4569ff5c4" kindref="member">setOutlineColor</ref>(<ref refid="structgf_1_1_color_1a7abeab052065d849d6a3f8b0d9ed57eb" kindref="member">gf::Color::Red</ref>);</highlight></codeline>
<codeline><highlight class="normal">star.<ref refid="classgf_1_1_shape_1a956e759ca015359dd229abfb12d22b2d" kindref="member">setOutlineThickness</ref>(5);</highlight></codeline>
<codeline><highlight class="normal">star.<ref refid="classgf_1_1_transformable_1a1110891882093c2e8cbfc839e3300dca" kindref="member">setPosition</ref>({<sp/>10.0f,<sp/>20.0f<sp/>});</highlight></codeline>
<codeline><highlight class="normal">...</highlight></codeline>
<codeline><highlight class="normal">window.draw(star);</highlight></codeline>
</programlisting>
</para><para><simplesect kind="see"><para><ref refid="classgf_1_1_shape" kindref="compound">gf::Shape</ref> </para></simplesect>
</para><br>

        
            
        
            
        
        <br>
    

    
        - <compoundname>gf::StretchView</compoundname><br>
        Brief desc: <para>Stretch view. </para><br>
        Full desc: <para>This view assumes that the screen is always the same size as the world. The world will then be stretched to fit the screen. There are no black bars, but the aspect ratio may not be the same after the scaling took place.</para><para><image type="html" name="stretchview.png">Stretch view</image>
 <simplesect kind="see"><para><ref refid="classgf_1_1_adaptative_view" kindref="compound">gf::AdaptativeView</ref> </para></simplesect>
</para><br>

        
            
        
        <br>
    

    
        - <compoundname>gf::StringRef</compoundname><br>
        Brief desc: <para>A constant reference to a string and its size. </para><br>
        Full desc: <para>This class stores a pointer to a string and its size. It can be built from various inputs: <computeroutput>std::string</computeroutput>, C string.</para><para><simplesect kind="see"><para><ref refid="classgf_1_1_array_ref" kindref="compound">gf::ArrayRef</ref>, <ref refid="classgf_1_1_buffer_ref" kindref="compound">gf::BufferRef</ref> </para></simplesect>
</para><br>

        
            
        
            
        
        <br>
    

    
        - <compoundname>gf::SystemInfo</compoundname><br>
        Brief desc: <para>A class for system info. </para><br>
        Full desc: <para>This class only contains static methods. You can get:</para><para><itemizedlist>
<listitem><para>the plaform name (e.g. "Linux")</para></listitem><listitem><para>the CPU cache line size</para></listitem><listitem><para>the number of CPU cores</para></listitem><listitem><para>the amount of memory (RAM) </para></listitem></itemizedlist>
</para><br>

        
            
        
            
        
        <br>
    

    
        - <compoundname>gf::Text</compoundname><br>
        Brief desc: <para>Graphical text that can be drawn to a render target. </para><br>
        Full desc: <para><ref refid="classgf_1_1_text" kindref="compound">gf::Text</ref> is a drawable class that allows to easily display some text with custom style and color on a render target.</para><para>It inherits all the functions from <ref refid="classgf_1_1_transformable" kindref="compound">gf::Transformable</ref>: position, rotation, scale, origin. It also adds text-specific properties such as the font to use, the character size, the global color and the text to display of course. It also provides convenience functions to calculate the graphical size of the text.</para><para><ref refid="classgf_1_1_text" kindref="compound">gf::Text</ref> works in combination with the <ref refid="classgf_1_1_font" kindref="compound">gf::Font</ref> class, which loads and provides the glyphs (visual characters) of a given font.</para><para>The separation of <ref refid="classgf_1_1_font" kindref="compound">gf::Font</ref> and <ref refid="classgf_1_1_text" kindref="compound">gf::Text</ref> allows more flexibility and better performances: indeed a <ref refid="classgf_1_1_font" kindref="compound">gf::Font</ref> is a heavy resource, and any operation on it is slow (often too slow for real-time applications). On the other side, a <ref refid="classgf_1_1_text" kindref="compound">gf::Text</ref> is a lightweight object which can combine the glyphs data and metrics of a <ref refid="classgf_1_1_font" kindref="compound">gf::Font</ref> to display any text on a render target.</para><para>It is important to note that the <ref refid="classgf_1_1_text" kindref="compound">gf::Text</ref> instance doesn't copy the font that it uses, it only keeps a reference to it. Thus, a <ref refid="classgf_1_1_font" kindref="compound">gf::Font</ref> must not be destructed while it is used by a <ref refid="classgf_1_1_text" kindref="compound">gf::Text</ref> (i.e. never write a function that uses a local <ref refid="classgf_1_1_font" kindref="compound">gf::Font</ref> instance for creating a text).</para><para>Usage example:</para><para>
  <programlisting><codeline><highlight class="comment">//<sp/>Declare<sp/>and<sp/>load<sp/>a<sp/>font</highlight><highlight class="normal"/></codeline>
<codeline><highlight class="normal"><ref refid="classgf_1_1_font" kindref="compound">gf::Font</ref><sp/>font;</highlight></codeline>
<codeline><highlight class="normal">font.<ref refid="classgf_1_1_font_1aa7d23688c81a7c31a5667547e1072501" kindref="member">loadFromFile</ref>(</highlight><highlight class="stringliteral">"arial.ttf"</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"/></codeline>
<codeline><highlight class="normal"/><highlight class="comment">//<sp/>Create<sp/>a<sp/>text</highlight><highlight class="normal"/></codeline>
<codeline><highlight class="normal"><ref refid="classgf_1_1_text" kindref="compound">gf::Text</ref><sp/>text(</highlight><highlight class="stringliteral">"hello"</highlight><highlight class="normal">,<sp/>font);</highlight></codeline>
<codeline><highlight class="normal">text.setCharacterSize(30);</highlight></codeline>
<codeline><highlight class="normal">text.setColor(<ref refid="structgf_1_1_color_1a7abeab052065d849d6a3f8b0d9ed57eb" kindref="member">gf::Color::Red</ref>);</highlight></codeline>
<codeline><highlight class="normal"/></codeline>
<codeline><highlight class="normal"/><highlight class="comment">//<sp/>Draw<sp/>it</highlight><highlight class="normal"/></codeline>
<codeline><highlight class="normal">rendered.draw(text);</highlight></codeline>
</programlisting>
</para><para><simplesect kind="see"><para><ref refid="classgf_1_1_font" kindref="compound">gf::Font</ref> </para></simplesect>
</para><br>

        
            
        
            
        
            
        
        <br>
    

    

    
        - <compoundname>gf::Texture</compoundname><br>
        Brief desc: <para>A texture for colored images. </para><br>
        Full desc: <para>A texture can be loaded from an image, but also directly from a file/memory/stream. The necessary shortcuts are defined so that you don't need an image first for the most common cases. However, if you want to perform some modifications on the pixels before creating the final texture, you can load your file to a <ref refid="classgf_1_1_image" kindref="compound">gf::Image</ref>, do whatever you need with the pixels, and then call <ref refid="classgf_1_1_texture_1a41b0c0263b7906a86b0ef1d483945f33" kindref="member">Texture::loadFromImage</ref>.</para><para>Like <ref refid="classgf_1_1_image" kindref="compound">gf::Image</ref>, <ref refid="classgf_1_1_texture" kindref="compound">gf::Texture</ref> can handle a unique internal representation of pixels, which is RGBA. This means that a pixel must be composed of 8 bits red, green, blue and alpha channels.</para><para>Usage example:</para><para>
  <programlisting><codeline><highlight class="comment">//<sp/>This<sp/>example<sp/>shows<sp/>the<sp/>most<sp/>common<sp/>use<sp/>of<sp/>gf::Texture:</highlight><highlight class="normal"/></codeline>
<codeline><highlight class="normal"/><highlight class="comment">//<sp/>drawing<sp/>a<sp/>sprite</highlight><highlight class="normal"/></codeline>
<codeline><highlight class="normal"/></codeline>
<codeline><highlight class="normal"/><highlight class="comment">//<sp/>Load<sp/>a<sp/>texture<sp/>from<sp/>a<sp/>file</highlight><highlight class="normal"/></codeline>
<codeline><highlight class="normal"><ref refid="classgf_1_1_texture" kindref="compound">gf::Texture</ref><sp/>texture;</highlight></codeline>
<codeline><highlight class="normal"/></codeline>
<codeline><highlight class="normal"/><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!texture.<ref refid="classgf_1_1_texture_1a4382398a8c7bcde5a4a2fba892a63ca7" kindref="member">loadFromFile</ref>(</highlight><highlight class="stringliteral">"texture.png"</highlight><highlight class="normal">))<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>-1;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"/></codeline>
<codeline><highlight class="normal"/><highlight class="comment">//<sp/>Assign<sp/>it<sp/>to<sp/>a<sp/>sprite</highlight><highlight class="normal"/></codeline>
<codeline><highlight class="normal"><ref refid="classgf_1_1_sprite" kindref="compound">gf::Sprite</ref><sp/>sprite;</highlight></codeline>
<codeline><highlight class="normal">sprite.<ref refid="classgf_1_1_sprite_1ac4f384f2bd71d8bbff2a5b4739d523bf" kindref="member">setTexture</ref>(texture);</highlight></codeline>
<codeline><highlight class="normal"/></codeline>
<codeline><highlight class="normal"/><highlight class="comment">//<sp/>Draw<sp/>the<sp/>textured<sp/>sprite</highlight><highlight class="normal"/></codeline>
<codeline><highlight class="normal">window.draw(sprite);</highlight></codeline>
</programlisting>
</para><para><simplesect kind="see"><para><ref refid="classgf_1_1_sprite" kindref="compound">gf::Sprite</ref>, <ref refid="classgf_1_1_image" kindref="compound">gf::Image</ref>, <ref refid="classgf_1_1_render_texture" kindref="compound">gf::RenderTexture</ref> </para></simplesect>
</para><br>

        
            
        
        <br>
    

    
        - <compoundname>gf::TextureAtlas</compoundname><br>
        Brief desc: <para>A collection of sub-texture. </para><br>
        Full desc: <para>A texture atlas is a collection of sub-texture that have been packed together in a single texture. The description of the sub-textures is done in a XML file. This description is a name and the texture coordinates in the texture.</para><para>Here is an example of a XML file containing an atlas:</para><para>
  <programlisting><codeline><highlight class="normal">&lt;</highlight><highlight class="keywordtype">TextureAtlas</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">imagePath</highlight><highlight class="normal">=</highlight><highlight class="stringliteral">"bricks.png"</highlight><highlight class="normal">&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>&lt;</highlight><highlight class="keywordtype">SubTexture</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">name</highlight><highlight class="normal">=</highlight><highlight class="stringliteral">"brickBlack01"</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">x</highlight><highlight class="normal">=</highlight><highlight class="stringliteral">"718"</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">y</highlight><highlight class="normal">=</highlight><highlight class="stringliteral">"500"</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">width</highlight><highlight class="normal">=</highlight><highlight class="stringliteral">"32"</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">height</highlight><highlight class="normal">=</highlight><highlight class="stringliteral">"32"</highlight><highlight class="normal">/&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>&lt;</highlight><highlight class="keywordtype">SubTexture</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">name</highlight><highlight class="normal">=</highlight><highlight class="stringliteral">"brickBlack02"</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">x</highlight><highlight class="normal">=</highlight><highlight class="stringliteral">"716"</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">y</highlight><highlight class="normal">=</highlight><highlight class="stringliteral">"66"</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">width</highlight><highlight class="normal">=</highlight><highlight class="stringliteral">"64"</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">height</highlight><highlight class="normal">=</highlight><highlight class="stringliteral">"32"</highlight><highlight class="normal">/&gt;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>...</highlight></codeline>
<codeline><highlight class="normal">&lt;/</highlight><highlight class="keywordtype">TextureAtlas</highlight><highlight class="normal">&gt;</highlight></codeline>
</programlisting>
</para><para><ref refid="classgf_1_1_texture_atlas" kindref="compound">gf::TextureAtlas</ref> is able to read the XML file and give the coordinates thanks to the name of the sub-texture, either in pixels or in texture normalized coordinates.</para><para><simplesect kind="see"><para><ref refid="classgf_1_1_texture" kindref="compound">gf::Texture</ref> </para></simplesect>
<simplesect kind="see"><para><ulink url="https://en.wikipedia.org/wiki/Texture_atlas">Texture Atlas (wikipedia)</ulink> </para></simplesect>
</para><br>

        
            
        
            
        
        <br>
    

    

    
        - <compoundname>gf::TileLayer</compoundname><br>
        Brief desc: <para>A tile layer. </para><br>
        Full desc: <para>A tile layer represents a map made of tiles. <ref refid="classgf_1_1_tile_layer" kindref="compound">gf::TileLayer</ref> makes it easy to draw a tile map.</para><para>A tile layer is associated to a single tileset. A tileset is a texture that contains all the tiles, ordered in a grid. The tileset has several parameters that are inspired by the parameters in <ulink url="http://www.mapeditor.org/">Tiled</ulink>:</para><para><itemizedlist>
<listitem><para>tile size: the size of a tile (<computeroutput><ref refid="classgf_1_1_tile_layer_1ae2e0c092c754f17e8dd11a22b60e8b4b" kindref="member">setTileSize()</ref></computeroutput>, <computeroutput><ref refid="classgf_1_1_tile_layer_1af2e7a54e60ed78fca4002dae560986df" kindref="member">getTileSize()</ref></computeroutput>)</para></listitem><listitem><para>margin: the margin around the tiles (<computeroutput><ref refid="classgf_1_1_tile_layer_1ad00e958c485bede01a6bf60fb7d7a0c5" kindref="member">setMargin()</ref></computeroutput>, <computeroutput><ref refid="classgf_1_1_tile_layer_1a266841d84f28d6539b11923779b21f14" kindref="member">getMargin()</ref></computeroutput>), default: 0</para></listitem><listitem><para>spacing: the spacing between the tiles (<computeroutput><ref refid="classgf_1_1_tile_layer_1ada3dc8bfaed30ab7d25aae913f2ec56f" kindref="member">setSpacing()</ref></computeroutput>, <computeroutput><ref refid="classgf_1_1_tile_layer_1aa3c35609ea24fee38c9a90e82f2078d7" kindref="member">getSpacing()</ref></computeroutput>), default: 0</para></listitem></itemizedlist>
</para><para>The tile layer is given with an array of indices. Each index correspond to a tile in the tileset. Tile 0 correspond to the tile at the top left in the tileset. Then tile are numbered from left to right, and then from top to bottom. If a tile is not present in the tile layer, the constant <ref refid="classgf_1_1_tile_layer_1a9ea62456a01e46446207cf5ae73a3cf4" kindref="member">gf::TileLayer::NoTile</ref> can be used. </para><br>

        
            

                <br><strong>Section: </strong>
                <header>Tileset parameters</header><br>

                
                    - <name>setTexture</name><br>
                
                    - <name>getTexture</name><br>
                
                    - <name>hasTexture</name><br>
                
                    - <name>unsetTexture</name><br>
                
                    - <name>setTileSize</name><br>
                
                    - <name>getTileSize</name><br>
                
                    - <name>setMargin</name><br>
                
                    - <name>setMargin</name><br>
                
                    - <name>getMargin</name><br>
                
                    - <name>setSpacing</name><br>
                
                    - <name>setSpacing</name><br>
                
                    - <name>getSpacing</name><br>
                

            
        
            

                <br><strong>Section: </strong>
                <header>Tile definition</header><br>

                
                    - <name>setBlockSize</name><br>
                
                    - <name>getBlockSize</name><br>
                
                    - <name>setTile</name><br>
                
                    - <name>getTile</name><br>
                
                    - <name>clear</name><br>
                

            
        
            
        
            
        
            
        
            
        
        <br>
    

    
        - <compoundname>gf::Time</compoundname><br>
        Brief desc: <para>Represents a time value. </para><br>
        Full desc: <para><ref refid="classgf_1_1_time" kindref="compound">gf::Time</ref> encapsulates a time value in a flexible way. It allows to define a time value either as a number of seconds, milliseconds or microseconds. It also works the other way round: you can read a time value as either a number of seconds, milliseconds or microseconds.</para><para>By using such a flexible interface, the API doesn't impose any fixed type or resolution for time values, and let the user choose its own favorite representation.</para><para>Since they represent a time span and not an absolute time value, times can also be negative.</para><para><ref refid="classgf_1_1_time" kindref="compound">gf::Time</ref> is a thin wrapper around C++11 <ulink url="http://en.cppreference.com/w/cpp/chrono/steady_clock">std::chrono::steady_clock</ulink>.</para><para>Usage example:</para><para>
  <programlisting><codeline><highlight class="normal"><ref refid="classgf_1_1_time" kindref="compound">gf::Time</ref><sp/>t1<sp/>=<sp/>gf::seconds(0.1f);</highlight></codeline>
<codeline><highlight class="normal">int32_t<sp/>milli<sp/>=<sp/>t1.<ref refid="classgf_1_1_time_1a1f122d2019823907cc36cc48455159d5" kindref="member">asMilliseconds</ref>();<sp/></highlight><highlight class="comment">//<sp/>100</highlight><highlight class="normal"/></codeline>
<codeline><highlight class="normal"/></codeline>
<codeline><highlight class="normal"><ref refid="classgf_1_1_time" kindref="compound">gf::Time</ref><sp/>t2<sp/>=<sp/>gf::milliseconds(30);</highlight></codeline>
<codeline><highlight class="normal">int64_t<sp/>micro<sp/>=<sp/>t2.<ref refid="classgf_1_1_time_1a9a53a6992d0ad455752f1086b99f2106" kindref="member">asMicroseconds</ref>();<sp/></highlight><highlight class="comment">//<sp/>30000</highlight><highlight class="normal"/></codeline>
<codeline><highlight class="normal"/></codeline>
<codeline><highlight class="normal"><ref refid="classgf_1_1_time" kindref="compound">gf::Time</ref><sp/>t3<sp/>=<sp/>gf::microseconds(-800000);</highlight></codeline>
<codeline><highlight class="normal"/><highlight class="keywordtype">float</highlight><highlight class="normal"><sp/>sec<sp/>=<sp/>t3.<ref refid="classgf_1_1_time_1a7812608f859bf55308cc35d874af5368" kindref="member">asSeconds</ref>();<sp/></highlight><highlight class="comment">//<sp/>-0.8</highlight></codeline>
</programlisting>
</para><para><simplesect kind="see"><para><ref refid="classgf_1_1_clock" kindref="compound">gf::Clock</ref> </para></simplesect>
</para><br>

        
            
        
            
        
            
        
            
        
            
        
        <br>
    

    

    

    

    

    

    

    

    

    

    

    

    

    

    
        - <compoundname>gf::TmxProperties</compoundname><br>
        Brief desc: <para>The properties for TMX entities. </para><br>
        Full desc: <br>

        
            
        
            
        
        <br>
    

    

    

    

    

    

    

    

    
        - <compoundname>gf::TmxVisitor</compoundname><br>
        Brief desc: <para>A visitor for layers in the visitor pattern. </para><br>
        Full desc: <para><simplesect kind="see"><para><ref refid="structgf_1_1_tmx_layer_1aac7dcc82aae5fdbd39144453e6fea3e4" kindref="member">gf::TmxLayer::accept()</ref> </para></simplesect>
<simplesect kind="see"><para><ulink url="https://en.wikipedia.org/wiki/Visitor_pattern">Wikipedia - Visitor pattern</ulink> </para></simplesect>
</para><br>

        
            
        
        <br>
    

    

    
        - <compoundname>gf::Transformable</compoundname><br>
        Brief desc: <para>Decomposed transform defined by a position, a rotation and a scale. </para><br>
        Full desc: <para><ref refid="group__core_1gae702e6021057443ca43f94b32618bbc2" kindref="member">gf::Matrix3f</ref>, as a low-level class, offers a great level of flexibility but it is not always convenient to manage. Indeed, one can easily combine any kind of operation, such as a translation followed by a rotation followed by a scaling, but once the result transform is built, there's no way to go backward and, let's say, change only the rotation without modifying the translation and scaling. The entire transform must be recomputed, which means that you need to retrieve the initial translation and scale factors as well, and combine them the same way you did before updating the rotation. This is a tedious operation, and it requires to store all the individual components of the final transform.</para><para>That's exactly what <ref refid="classgf_1_1_transformable" kindref="compound">gf::Transformable</ref> was written for: it hides these variables and the composed transform behind an easy to use interface. You can set or get any of the individual components without worrying about the others. It also provides the composed transform (as a <ref refid="group__core_1gae702e6021057443ca43f94b32618bbc2" kindref="member">gf::Matrix3f</ref>), and keeps it up-to-date.</para><para>In addition to the position, rotation and scale, <ref refid="classgf_1_1_transformable" kindref="compound">gf::Transformable</ref> provides an "origin" component, which represents the local origin of the three other components. Let's take an example with a 10x10 pixels sprite. By default, the sprite is positioned/rotated/scaled relatively to its top-left corner, because it is the local point <formula id="89">$(0, 0)$</formula>. But if we change the origin to be <formula id="90">$(5, 5)$</formula>, the sprite will be positioned/rotated/scaled around its center instead. And if we set the origin to <formula id="91">$(10, 10)$</formula>, it will be transformed around its bottom-right corner.</para><para>To keep the <ref refid="classgf_1_1_transformable" kindref="compound">gf::Transformable</ref> class simple, there's only one origin for all the components. You cannot position the sprite relatively to its top-left corner while rotating it around its center, for example. To do such things, use <ref refid="group__core_1gae702e6021057443ca43f94b32618bbc2" kindref="member">gf::Matrix3f</ref> directly.</para><para><ref refid="classgf_1_1_transformable" kindref="compound">gf::Transformable</ref> can be used as a base class. That's what gf's sprites, texts, curves and shapes do.</para><para>
  <programlisting><codeline><highlight class="keyword">class<sp/></highlight><highlight class="normal">MyEntity<sp/>:<sp/></highlight><highlight class="keyword">public</highlight><highlight class="normal"><sp/><ref refid="classgf_1_1_transformable" kindref="compound">gf::Transformable</ref><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">virtual</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/><ref refid="classgf_1_1_drawable_1a01535a84e4fb6222311ceb81accc4a27" kindref="member">draw</ref>(<ref refid="classgf_1_1_render_target" kindref="compound">gf::RenderTarget</ref>&amp;<sp/>target,<sp/><ref refid="structgf_1_1_render_states" kindref="compound">gf::RenderStates</ref><sp/>states)</highlight><highlight class="keyword"><sp/>override<sp/></highlight><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>states.<ref refid="structgf_1_1_render_states_1a8ebe53edcc7e0d84865a47a41a1f30d0" kindref="member">transform</ref><sp/>*=<sp/><ref refid="classgf_1_1_transformable_1aa742e95c087b0340bcff458b8872e2ea" kindref="member">getTransform</ref>();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>target.<ref refid="classgf_1_1_render_target_1a3445880f95c648efbeff3d2572c4c263" kindref="member">draw</ref>(...,<sp/>states);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal"/></codeline>
<codeline><highlight class="normal">MyEntity<sp/>entity;</highlight></codeline>
<codeline><highlight class="normal">entity.setPosition(10,<sp/>20);</highlight></codeline>
<codeline><highlight class="normal">entity.setRotation(45);</highlight></codeline>
<codeline><highlight class="normal">renderer.<ref refid="classgf_1_1_render_target_1a3445880f95c648efbeff3d2572c4c263" kindref="member">draw</ref>(entity);</highlight></codeline>
</programlisting>
</para><para><simplesect kind="see"><para><ref refid="group__core_1gae702e6021057443ca43f94b32618bbc2" kindref="member">gf::Matrix3f</ref> </para></simplesect>
</para><br>

        
            
        
            
        
            
        
        <br>
    

    

    
        - <compoundname>gf::Tween</compoundname><br>
        Brief desc: <para>An interpolation between two values. </para><br>
        Full desc: <para><simplesect kind="see"><para><ulink url="https://en.wikipedia.org/wiki/Inbetweening">Inbetweening - Wikipedia</ulink> </para></simplesect>
</para><br>

        
            
        
            
        
            
        
        <br>
    

    
        - <compoundname>gf::UI</compoundname><br>
        Brief desc: <para>Context for an immediate mode graphical interface. </para><br>
        Full desc: <para>When building a graphical interfaces, you have basically two choices: either the retained mode where you build a hierarchy of widgets, or the immediate mode where widgets are built from function calls. Choosing the best mode between these two may be <ulink url="http://gamedev.stackexchange.com/questions/24103/immediate-gui-yae-or-nay">controversial</ulink>. gf offers an immediate mode graphical interface through this class.</para><para>The immediate mode graphical interface (or imgui) of gf is based on <ulink url="https://github.com/vurtun/nuklear">Nuklear</ulink>, a C library with the same purpose. gf does not provide (yet?) all the features of Nuklear, but a fair amount of the main features. Nuklear is totally abstracted in gf so you won't see any interface from Nuklear and you won't be able to interact directly with Nuklear. If you need a feature that is not implemented yet, just ask.</para><para>This imgui library can be used to create tools for the game developpers. It's easy and quick to build a functional interface with an imgui library. You can see some examples in gf itself. You can also use this library to build in-game interfaces, even if it's not its primary purpose. If your game is heavily based on a graphical interface, it may be a good option.</para><para><heading level="1">Creating a context</heading>
</para><para>An instance of <ref refid="classgf_1_1_u_i" kindref="compound">gf::UI</ref> is a context for all the windows that will be created. You must provide a font and a character size that will be used in the interface. Generally, you create the instance of <ref refid="classgf_1_1_u_i" kindref="compound">gf::UI</ref> at the beginning of your application and then you use this instance throughout your application.</para><para><programlisting><codeline><highlight class="normal"><sp/><sp/><ref refid="classgf_1_1_font" kindref="compound">gf::Font</ref><sp/>font;</highlight></codeline>
<codeline><highlight class="normal"/></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!font.<ref refid="classgf_1_1_font_1aa7d23688c81a7c31a5667547e1072501" kindref="member">loadFromFile</ref>(</highlight><highlight class="stringliteral">"font.ttf"</highlight><highlight class="normal">))<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>EXIT_FAILURE;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"/></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="classgf_1_1_u_i" kindref="compound">gf::UI</ref><sp/>ui(font,<sp/>13);</highlight></codeline>
</programlisting> By default, the character size is 13.</para><para><heading level="1">Managing events</heading>
</para><para>The imgui needs to know the input events that occurred in the frame time. So when polling the events in your main loop, you must pass the events to the context so that it can be updated and take the good decision. For example, if you press on a button, the mouse event will be transmitted and the library will know that you pressed a button and act accordingly.</para><para>
  <programlisting><codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structgf_1_1_event" kindref="compound">gf::Event</ref><sp/>event;</highlight></codeline>
<codeline><highlight class="normal"/></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(window.<ref refid="classgf_1_1_window_1a88c202262d1e22f23f164247381deaa6" kindref="member">pollEvent</ref>(event))<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">switch</highlight><highlight class="normal"><sp/>(event.<ref refid="structgf_1_1_event_1a764707270173af5b617ed6589a58dfe1" kindref="member">type</ref>)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">case</highlight><highlight class="normal"><sp/><ref refid="group__window_1gga244fb10415539f03cde7ed0ae916018da03f4a47830f97377a35321051685071e" kindref="member">gf::EventType::Closed</ref>:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>window.<ref refid="classgf_1_1_window_1a653d8e56d4c27da4aced0dc702edb8a8" kindref="member">close</ref>();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">break</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"/></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">default</highlight><highlight class="normal">:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">break</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"/></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>ui.processEvent(event);<sp/></highlight><highlight class="comment">//<sp/>update<sp/>the<sp/>imgui<sp/>with<sp/>input<sp/>events</highlight><highlight class="normal"/></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
</programlisting>
</para><para><heading level="1">Creating a window</heading>
</para><para>Then, you have to create a window. The window has a title that may appear in the titlebar. It also identifies the window so two windows must have two different titles. The window also has bounds, i.e. a position and a size, that indicates where to put the window in the screen. There is no automatic placement of windows. Finally, the window can have many properties (see <ref refid="group__graphics_1ga1f6e0cfb0a30fef018c7dfa724ae6e20" kindref="member">gf::UIWindow</ref>) that modify the interaction with the window. They are defined at the window creation.</para><para><programlisting><codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(ui.begin(</highlight><highlight class="stringliteral">"Title"</highlight><highlight class="normal">,<sp/><ref refid="structgf_1_1_rect" kindref="compound">gf::RectF</ref>(20,<sp/>20,<sp/>200,<sp/>200),<sp/><ref refid="group__graphics_1gga1f6e0cfb0a30fef018c7dfa724ae6e20ab78a3223503896721cca1303f776159b" kindref="member">gf::UIWindow::Title</ref><sp/>|<sp/><ref refid="group__graphics_1gga1f6e0cfb0a30fef018c7dfa724ae6e20a070554647306343cbea29ebfdd278ba8" kindref="member">gf::UIWindow::Border</ref>))<sp/>{</highlight></codeline>
<codeline><highlight class="normal"/></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>content<sp/>of<sp/>the<sp/>window</highlight><highlight class="normal"/></codeline>
<codeline><highlight class="normal"/></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"/></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>ui.end();</highlight></codeline>
</programlisting> For each <ref refid="classgf_1_1_u_i_1a50503bc596243ddc42a78aa84d6b7c5c" kindref="member">begin()</ref>, you have to call <ref refid="classgf_1_1_u_i_1a2d54a12952406594826e93ff00c67d56" kindref="member">end()</ref> to finish the window. You can create as many windows as you want as long as they have different titles.</para><para><heading level="1">Determining a layout</heading>
</para><para>Before drawing any widget, you have to define a layout. Think of it as a sort of specification for how to organize the following widgets. There are three types of layouts: rows, groups, trees.</para><para><heading level="2">Rows</heading>
</para><para>Rows are the most common type of layout. The row layout is very flexible.</para><para>A row can be either static (it does not adapt to the width of the window) of dynamic (it adapts to the width of the window). It can be fixed (all columns have the same width) or custom (columns' widths are specified, either relatively or absolutely), and in the latter case the specification can be global or in immediate mode. Here is a summary of the functions to use in each case:</para><para><itemizedlist>
<listitem><para>dynamic row<itemizedlist>
<listitem><para>fixed column layout: <ref refid="classgf_1_1_u_i_1a507a56deaaa6eecf102e92243cd2a3bb" kindref="member">layoutRowDynamic()</ref></para></listitem><listitem><para>custom column layout<itemizedlist>
<listitem><para>array-based: <ref refid="classgf_1_1_u_i_1ac0e52e0df2a1e02c37788a584f9a7741" kindref="member">layoutRow()</ref> with <ref refid="group__graphics_1gga6a42c4039729410b3839e01afe754719a971fd8cc345d8bd9f92e9f7d88fdf20c" kindref="member">gf::UILayout::Dynamic</ref></para></listitem><listitem><para>immediate-mode: <ref refid="classgf_1_1_u_i_1a07b2a56e4c4468e779c1c528dd0a887b" kindref="member">layoutRowBegin()</ref> with <ref refid="group__graphics_1gga6a42c4039729410b3839e01afe754719a971fd8cc345d8bd9f92e9f7d88fdf20c" kindref="member">gf::UILayout::Dynamic</ref>, <ref refid="classgf_1_1_u_i_1a1eb611a4762282923f629380b5280550" kindref="member">layoutRowPush()</ref>, <ref refid="classgf_1_1_u_i_1a3ce2eb3900039c1f2bf69ad4afc2e0bf" kindref="member">layoutRowEnd()</ref></para></listitem></itemizedlist>
</para></listitem></itemizedlist>
</para></listitem><listitem><para>static row<itemizedlist>
<listitem><para>fixed column layout: <ref refid="classgf_1_1_u_i_1ab6f2e0bc248a3bc5ba1b352764e8b821" kindref="member">layoutRowStatic()</ref></para></listitem><listitem><para>custom column layout<itemizedlist>
<listitem><para>array-based: <ref refid="classgf_1_1_u_i_1ac0e52e0df2a1e02c37788a584f9a7741" kindref="member">layoutRow()</ref> with <ref refid="group__graphics_1gga6a42c4039729410b3839e01afe754719a84a8921b25f505d0d2077aeb5db4bc16" kindref="member">gf::UILayout::Static</ref></para></listitem><listitem><para>immediate-mode: <ref refid="classgf_1_1_u_i_1a07b2a56e4c4468e779c1c528dd0a887b" kindref="member">layoutRowBegin()</ref> with <ref refid="group__graphics_1gga6a42c4039729410b3839e01afe754719a84a8921b25f505d0d2077aeb5db4bc16" kindref="member">gf::UILayout::Static</ref>, <ref refid="classgf_1_1_u_i_1a1eb611a4762282923f629380b5280550" kindref="member">layoutRowPush()</ref>, <ref refid="classgf_1_1_u_i_1a3ce2eb3900039c1f2bf69ad4afc2e0bf" kindref="member">layoutRowEnd()</ref></para></listitem></itemizedlist>
</para></listitem></itemizedlist>
</para></listitem></itemizedlist>
</para><para><heading level="2">Trees</heading>
</para><para>A tree is a tree-like layout. It can be collapsed to hide its content except its title. There are two types of trees: tabs and nodes (see <ref refid="group__graphics_1ga08e52c09767f611e8578fb66a0c4644e" kindref="member">gf::UITree</ref>). A tab tree is generally put at the root of the tree, it is represented with a border around the title. A node tree is generally the son of a tab tree or another node tree. It is represented without any border.</para><para>In both cases, you need a variable of type <ref refid="group__graphics_1gab12328ea0a85c97bf28742e12aa76cb4" kindref="member">gf::UICollapse</ref> to handle the current state of the tree: minimized or maximized.</para><para><programlisting><codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/><ref refid="group__graphics_1gab12328ea0a85c97bf28742e12aa76cb4" kindref="member">gf::UICollapse</ref><sp/>rootCollapsed<sp/>=<sp/><ref refid="group__graphics_1ggab12328ea0a85c97bf28742e12aa76cb4a074afcc50ae51f248cbae4950845549e" kindref="member">gf::UICollapse::Minimized</ref>;</highlight></codeline>
<codeline><highlight class="normal"/></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(ui.treePush(<ref refid="group__window_1gga795d7d5e2f2a4f38b16b95e0e78cb626a5c6ba25104401c9ee0650230fc6ba413" kindref="member">gf::UITree::Tab</ref>,<sp/></highlight><highlight class="stringliteral">"Root"</highlight><highlight class="normal">,<sp/>rootCollapsed))<sp/>{</highlight></codeline>
<codeline><highlight class="normal"/></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keyword">static</highlight><highlight class="normal"><sp/><ref refid="group__graphics_1gab12328ea0a85c97bf28742e12aa76cb4" kindref="member">gf::UICollapse</ref><sp/>childCollapsed<sp/>=<sp/><ref refid="group__graphics_1ggab12328ea0a85c97bf28742e12aa76cb4a49d903a5c02560cf79bf6b516cc89457" kindref="member">gf::UICollapse::Maximized</ref>;</highlight></codeline>
<codeline><highlight class="normal"/></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(ui.treePush(<ref refid="group__graphics_1gga08e52c09767f611e8578fb66a0c4644ea6c3a6944a808a7c0bbb6788dbec54a9f" kindref="member">gf::UITree::Node</ref>,<sp/></highlight><highlight class="stringliteral">"Child"</highlight><highlight class="normal">,<sp/>childCollapsed))<sp/>{</highlight></codeline>
<codeline><highlight class="normal"/></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>content<sp/>of<sp/>the<sp/>child<sp/>node</highlight><highlight class="normal"/></codeline>
<codeline><highlight class="normal"/></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>ui.treePop();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"/></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>next<sp/>content<sp/>of<sp/>the<sp/>root<sp/>node</highlight><highlight class="normal"/></codeline>
<codeline><highlight class="normal"/></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>ui.treePop();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
</programlisting> <heading level="2">Groups</heading>
</para><para>A group is a kind of window inside a window. It can have a title, a border and a scrollbar. However, a group needs to be put in a row. See <ref refid="classgf_1_1_u_i_1a0f417ea6c6d0e5ed793170550eb3ffd4" kindref="member">groupBegin()</ref> and <ref refid="classgf_1_1_u_i_1acd1e50425ba731b2eb66e0cab6ef357c" kindref="member">groupEnd()</ref>.</para><para>
  <programlisting><codeline><highlight class="normal"><sp/><sp/><sp/><sp/>ui.layoutRowStatic(groupHeight,<sp/>groupWidth,<sp/>2);</highlight></codeline>
<codeline><highlight class="normal"/></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(ui.groupBegin(</highlight><highlight class="stringliteral">"Group"</highlight><highlight class="normal">,<sp/><ref refid="group__graphics_1gga1f6e0cfb0a30fef018c7dfa724ae6e20ab78a3223503896721cca1303f776159b" kindref="member">gf::UIWindow::Title</ref><sp/>|<sp/><ref refid="group__graphics_1gga1f6e0cfb0a30fef018c7dfa724ae6e20a070554647306343cbea29ebfdd278ba8" kindref="member">gf::UIWindow::Border</ref>))<sp/>{</highlight></codeline>
<codeline><highlight class="normal"/></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>content<sp/>of<sp/>the<sp/>group</highlight><highlight class="normal"/></codeline>
<codeline><highlight class="normal"/></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>ui.groupEnd();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
</programlisting>
</para><para><heading level="1">Adding widgets and more</heading>
</para><para>The library offers common kinds of widgets:<itemizedlist>
<listitem><para><ulink url="https://en.wikipedia.org/wiki/Label_%28control%29">labels</ulink>: <ref refid="classgf_1_1_u_i_1a0da41c78e21b98737fbd1be3ad4333af" kindref="member">label()</ref>, <ref refid="classgf_1_1_u_i_1a3eef3c61be59ac55399bdb718d5837ab" kindref="member">selectableLabel()</ref></para></listitem><listitem><para><ulink url="https://en.wikipedia.org/wiki/Button_%28computing%29">buttons</ulink>: <ref refid="classgf_1_1_u_i_1a6aa8feb99000165ce542b716b1f6067e" kindref="member">buttonLabel()</ref>, <ref refid="classgf_1_1_u_i_1a03589bf4661a1c0f7eed923bda71d737" kindref="member">buttonColor()</ref>, <ref refid="classgf_1_1_u_i_1a722b82d2444a0c422e8a43f096fe8795" kindref="member">buttonSymbol()</ref>, <ref refid="classgf_1_1_u_i_1a9e4cc3f7b9eb737275224296512a06fd" kindref="member">buttonSymbolLabel()</ref></para></listitem><listitem><para><ulink url="https://en.wikipedia.org/wiki/Checkbox">checkboxes</ulink>: <ref refid="classgf_1_1_u_i_1af1aa9f995cda346ca0599ff22598fa4b" kindref="member">checkbox()</ref>, <ref refid="classgf_1_1_u_i_1ada5876a7009b62961398d7fe7e101748" kindref="member">checkboxFlags()</ref></para></listitem><listitem><para><ulink url="https://en.wikipedia.org/wiki/Radio_button">radio buttons</ulink>: <ref refid="classgf_1_1_u_i_1a28fcbaa8eb6e6dada63da19f24fb60ec" kindref="member">option()</ref>, <ref refid="classgf_1_1_u_i_1aaf0fd0bef4258ac3e3d8caa00bff7c75" kindref="member">radio()</ref></para></listitem><listitem><para><ulink url="https://en.wikipedia.org/wiki/Slider_%28computing%29">sliders</ulink>: <ref refid="classgf_1_1_u_i_1a4bac30f1ff0b02140f3c005401945e2d" kindref="member">sliderFloat()</ref>, <ref refid="classgf_1_1_u_i_1a55eb6ac28e684fc06045bcbc7aac36af" kindref="member">sliderInt()</ref></para></listitem><listitem><para><ulink url="https://en.wikipedia.org/wiki/Progress_bar">progress bars</ulink>: <ref refid="classgf_1_1_u_i_1ab36c4a86436e40c78dbcb9aaf48f2f5f" kindref="member">progress()</ref></para></listitem><listitem><para><ulink url="https://en.wikipedia.org/wiki/Color_tool">color pickers</ulink>: <ref refid="classgf_1_1_u_i_1abceadbe761b49e1f5585c1aebd177b28" kindref="member">colorPicker()</ref></para></listitem></itemizedlist>
</para><para>Widgets often manipulate a reference to a user-provided variable that represents the state of the widget. This way, you can pass directly your model variables to the graphical interface without duplicating the data. Some widgets return a boolean that indicates a state change. For example, a button returns true if it has been pressed.</para><para>The library also offers common graphical interface elements:<itemizedlist>
<listitem><para><ulink url="https://en.wikipedia.org/wiki/Popover_%28GUI%29">popups</ulink>: <ref refid="classgf_1_1_u_i_1a725cc2f102c84c61ea56d8b4f27bf9a2" kindref="member">popupBegin()</ref>, <ref refid="classgf_1_1_u_i_1a35d43aa89a115c04889f397744f8e880" kindref="member">popupEnd()</ref></para></listitem><listitem><para><ulink url="https://en.wikipedia.org/wiki/Combo_box">combo boxes</ulink>: <ref refid="classgf_1_1_u_i_1a81176bad4dc2628bccb3ab06ec2957f8" kindref="member">combobox()</ref>, <ref refid="classgf_1_1_u_i_1a98289a8052dd670ad0b606189b67c382" kindref="member">comboboxSeparator()</ref></para></listitem><listitem><para><ulink url="https://en.wikipedia.org/wiki/Context_menu">contextuals</ulink>: <ref refid="classgf_1_1_u_i_1a6de6b47b7c25fc110dd47ffecae292c2" kindref="member">contextualBegin()</ref>, <ref refid="classgf_1_1_u_i_1ae439885cfe70c67bc1e347a155118a54" kindref="member">contextualEnd()</ref></para></listitem><listitem><para><ulink url="https://en.wikipedia.org/wiki/Tooltip">tooltips</ulink>: <ref refid="classgf_1_1_u_i_1a87daae5e597a04565f80bb0597f787af" kindref="member">tooltip()</ref></para></listitem><listitem><para><ulink url="https://en.wikipedia.org/wiki/Menu_28computing%29">menus</ulink>: <ref refid="classgf_1_1_u_i_1ab866397ba70f2dbd6dc346a58c99cce7" kindref="member">menubarBegin()</ref>, <ref refid="classgf_1_1_u_i_1a328ed0fff035d978f85a60e3ff7821fb" kindref="member">menubarEnd()</ref></para></listitem></itemizedlist>
</para><para>Many of these elements have a begin/end API. The end part must be called if the begin part succeeded, i.e. returned true. Some elements offer a simplified version without begin/end for common cases. </para><br>

        
            

                <br><strong>Section: </strong>
                <header>Window</header><br>

                
                    - <name>begin</name><br>
                
                    - <name>end</name><br>
                
                    - <name>windowGetBounds</name><br>
                

            
        
            

                <br><strong>Section: </strong>
                <header>Layout</header><br>

                
                    - <name>layoutRowDynamic</name><br>
                
                    - <name>layoutRowStatic</name><br>
                
                    - <name>layoutRowBegin</name><br>
                
                    - <name>layoutRowPush</name><br>
                
                    - <name>layoutRowEnd</name><br>
                
                    - <name>layoutRow</name><br>
                
                    - <name>separator</name><br>
                

            
        
            

                <br><strong>Section: </strong>
                <header>Layout: Group</header><br>

                
                    - <name>groupBegin</name><br>
                
                    - <name>groupEnd</name><br>
                
                    - <name>groupScrolledBegin</name><br>
                
                    - <name>groupScrolledEnd</name><br>
                

            
        
            

                <br><strong>Section: </strong>
                <header>Layout: Tree</header><br>

                
                    - <name>treePush</name><br>
                
                    - <name>treePop</name><br>
                

            
        
            

                <br><strong>Section: </strong>
                <header>Widgets: Labels</header><br>

                
                    - <name>label</name><br>
                
                    - <name>labelColored</name><br>
                
                    - <name>labelWrap</name><br>
                
                    - <name>labelWrapColored</name><br>
                
                    - <name>image</name><br>
                

            
        
            

                <br><strong>Section: </strong>
                <header>Widgets: Buttons</header><br>

                
                    - <name>buttonSetBehavior</name><br>
                
                    - <name>buttonPushBehavior</name><br>
                
                    - <name>buttonPopBehavior</name><br>
                
                    - <name>buttonLabel</name><br>
                
                    - <name>buttonColor</name><br>
                
                    - <name>buttonSymbol</name><br>
                
                    - <name>buttonSymbolLabel</name><br>
                

            
        
            

                <br><strong>Section: </strong>
                <header>Widgets: Checkbox</header><br>

                
                    - <name>checkbox</name><br>
                
                    - <name>checkboxFlags</name><br>
                

            
        
            

                <br><strong>Section: </strong>
                <header>Widgets: Radio</header><br>

                
                    - <name>option</name><br>
                
                    - <name>radio</name><br>
                

            
        
            

                <br><strong>Section: </strong>
                <header>Widgets: Selectable</header><br>

                
                    - <name>selectableLabel</name><br>
                

            
        
            

                <br><strong>Section: </strong>
                <header>Widgets: Slider</header><br>

                
                    - <name>sliderFloat</name><br>
                
                    - <name>sliderInt</name><br>
                

            
        
            

                <br><strong>Section: </strong>
                <header>Widgets: Progressbar</header><br>

                
                    - <name>progress</name><br>
                

            
        
            

                <br><strong>Section: </strong>
                <header>Widgets: Color picker</header><br>

                
                    - <name>colorPicker</name><br>
                

            
        
            

                <br><strong>Section: </strong>
                <header>Widgets: Property</header><br>

                
                    - <name>propertyInt</name><br>
                
                    - <name>propertyFloat</name><br>
                
                    - <name>propertyDouble</name><br>
                

            
        
            

                <br><strong>Section: </strong>
                <header>Widgets: TextEdit</header><br>

                
                    - <name>edit</name><br>
                

            
        
            

                <br><strong>Section: </strong>
                <header>Dialogs</header><br>

                
                    - <name>fileSelector</name><br>
                

            
        
            

                <br><strong>Section: </strong>
                <header>Popups</header><br>

                
                    - <name>popupBegin</name><br>
                
                    - <name>popupClose</name><br>
                
                    - <name>popupEnd</name><br>
                

            
        
            

                <br><strong>Section: </strong>
                <header>Combo box</header><br>

                
                    - <name>combobox</name><br>
                
                    - <name>comboboxSeparator</name><br>
                
                    - <name>comboBeginLabel</name><br>
                
                    - <name>comboBeginColor</name><br>
                
                    - <name>comboBeginSymbol</name><br>
                
                    - <name>comboBeginSymbolLabel</name><br>
                
                    - <name>comboItemLabel</name><br>
                
                    - <name>comboItemSymbolLabel</name><br>
                
                    - <name>comboClose</name><br>
                
                    - <name>comboEnd</name><br>
                

            
        
            

                <br><strong>Section: </strong>
                <header>Contextual</header><br>

                
                    - <name>contextualBegin</name><br>
                
                    - <name>contextualItemLabel</name><br>
                
                    - <name>contextualItemSymbolLabel</name><br>
                
                    - <name>contextualClose</name><br>
                
                    - <name>contextualEnd</name><br>
                

            
        
            

                <br><strong>Section: </strong>
                <header>Tooltip</header><br>

                
                    - <name>tooltip</name><br>
                
                    - <name>tooltipBegin</name><br>
                
                    - <name>tooltipEnd</name><br>
                

            
        
            

                <br><strong>Section: </strong>
                <header>Menu</header><br>

                
                    - <name>menubarBegin</name><br>
                
                    - <name>menubarEnd</name><br>
                
                    - <name>menuBeginLabel</name><br>
                
                    - <name>menuBeginSymbol</name><br>
                
                    - <name>menuBeginSymbolLabel</name><br>
                
                    - <name>menuItemLabel</name><br>
                
                    - <name>menuItemSymbolLabel</name><br>
                
                    - <name>menuClose</name><br>
                
                    - <name>menuEnd</name><br>
                

            
        
            

                <br><strong>Section: </strong>
                <header>Utilities</header><br>

                
                    - <name>getWidgetBounds</name><br>
                
                    - <name>isWidgetHovered</name><br>
                
                    - <name>spacing</name><br>
                

            
        
            

                <br><strong>Section: </strong>
                <header>Style</header><br>

                
                    - <name>setPredefinedStyle</name><br>
                

            
        
            
        
            
        
            
        
            
        
            
        
        <br>
    

    

    

    
        - <compoundname>gf::ValueActivity</compoundname><br>
        Brief desc: <para>An activity for a simple float value. </para><br>
        Full desc: <para><simplesect kind="see"><para><ref refid="classgf_1_1_tween" kindref="compound">gf::Tween</ref> </para></simplesect>
</para><br>

        
            
        
            
        
        <br>
    

    
        - <compoundname>gf::ValueNoise2D</compoundname><br>
        Brief desc: <para>Value 2D noise. </para><br>
        Full desc: <para><ulink url="https://en.wikipedia.org/wiki/Value_noise">Value noise</ulink> is a lattice-based noise based on values. </para><br>

        
            
        
            
        
            
        
        <br>
    

    

    

    

    

    

    

    
        - <compoundname>gf::VertexArray</compoundname><br>
        Brief desc: <para>A set of primitives. </para><br>
        Full desc: <para><ref refid="classgf_1_1_vertex_array" kindref="compound">gf::VertexArray</ref> is a very simple wrapper around a dynamic array of vertices and a primitive type.</para><para>It inherits <ref refid="classgf_1_1_drawable" kindref="compound">gf::Drawable</ref>, but unlike other drawables it is not transformable.</para><para>Example:</para><para>
  <programlisting><codeline><highlight class="normal"><ref refid="classgf_1_1_vertex_array" kindref="compound">gf::VertexArray</ref><sp/>lines(<ref refid="group__graphics_1gga147b34accfb774f4ea41ab0cb94f28e1ae7f9e73b8edd21f420a63b3ace5768a2" kindref="member">gf::PrimitiveType::LineStrip</ref>,<sp/>4);</highlight></codeline>
<codeline><highlight class="normal">lines[0].position<sp/>=<sp/><ref refid="group__core_1ga6036002b111f9c4216809da953818625" kindref="member">gf::Vector2f</ref>(10,<sp/>0);</highlight></codeline>
<codeline><highlight class="normal">lines[1].position<sp/>=<sp/><ref refid="group__core_1ga6036002b111f9c4216809da953818625" kindref="member">gf::Vector2f</ref>(20,<sp/>0);</highlight></codeline>
<codeline><highlight class="normal">lines[2].position<sp/>=<sp/><ref refid="group__core_1ga6036002b111f9c4216809da953818625" kindref="member">gf::Vector2f</ref>(30,<sp/>5);</highlight></codeline>
<codeline><highlight class="normal">lines[3].position<sp/>=<sp/><ref refid="group__core_1ga6036002b111f9c4216809da953818625" kindref="member">gf::Vector2f</ref>(40,<sp/>2);</highlight></codeline>
<codeline><highlight class="normal"/></codeline>
<codeline><highlight class="normal">window.draw(lines);</highlight></codeline>
</programlisting>
</para><para><simplesect kind="see"><para><ref refid="structgf_1_1_vertex" kindref="compound">gf::Vertex</ref> </para></simplesect>
</para><br>

        
            
        
            
        
        <br>
    

    
        - <compoundname>gf::VertexBuffer</compoundname><br>
        Brief desc: <para>Data in the graphics memory. </para><br>
        Full desc: <para>A vertex buffer is a buffer that resides directly in the graphics memory. The advantage is that the draw operations are faster than uploading data each time. The drawback is that the data must not change, i.e. data can be loaded only once.</para><para>In gf, a vertex buffer can be used directly. But the main usage is for drawable entities that can upload the final geometry and give the corresponding vertex buffer.</para><para>Usage:</para><para>
  <programlisting><codeline><highlight class="normal"><ref refid="classgf_1_1_texture" kindref="compound">gf::Texture</ref><sp/>texture;</highlight></codeline>
<codeline><highlight class="normal"/></codeline>
<codeline><highlight class="normal"><ref refid="classgf_1_1_sprite" kindref="compound">gf::Sprite</ref><sp/>sprite;</highlight></codeline>
<codeline><highlight class="normal"/></codeline>
<codeline><highlight class="normal">sprite.<ref refid="classgf_1_1_sprite_1ac4f384f2bd71d8bbff2a5b4739d523bf" kindref="member">setTexture</ref>(texture);</highlight></codeline>
<codeline><highlight class="normal">sprite.<ref refid="classgf_1_1_sprite_1ad62ac864a6937a8f6b229016b71d7bad" kindref="member">setTextureRect</ref>({<sp/>0.5f,<sp/>0.5f,<sp/>0.25f,<sp/>0.25f<sp/>});</highlight></codeline>
<codeline><highlight class="normal"><ref refid="classgf_1_1_vertex_buffer" kindref="compound">gf::VertexBuffer</ref><sp/>buffer<sp/>=<sp/>sprite.<ref refid="classgf_1_1_sprite_1acc292dcf8376169811ae28996b38c749" kindref="member">commitGeometry</ref>();</highlight></codeline>
<codeline><highlight class="normal"/></codeline>
<codeline><highlight class="normal"><ref refid="classgf_1_1_buffered_geometry" kindref="compound">gf::BufferedGeometry</ref><sp/>geometry;</highlight></codeline>
<codeline><highlight class="normal">geometry.<ref refid="classgf_1_1_buffered_geometry_1a48a306aae3ff919d7fc43491f94a6349" kindref="member">setBuffer</ref>(buffer);</highlight></codeline>
<codeline><highlight class="normal">geometry.<ref refid="classgf_1_1_buffered_geometry_1a4b4c46d8b66e5f4e428ebb2feb1795aa" kindref="member">setTexture</ref>(texture);</highlight></codeline>
<codeline><highlight class="normal"/></codeline>
<codeline><highlight class="normal">renderer.<ref refid="classgf_1_1_render_target_1a3445880f95c648efbeff3d2572c4c263" kindref="member">draw</ref>(geometry);</highlight></codeline>
</programlisting>
</para><para><simplesect kind="see"><para><ref refid="classgf_1_1_buffered_geometry" kindref="compound">gf::BufferedGeometry</ref> </para></simplesect>
</para><br>

        
            
        
            
        
            
        
        <br>
    

    

    
        - <compoundname>gf::View</compoundname><br>
        Brief desc: <para>2D camera that defines what region is shown on screen </para><br>
        Full desc: <para><ref refid="classgf_1_1_view" kindref="compound">gf::View</ref> defines a camera in the 2D scene. This is a very powerful concept: you can scroll, rotate or zoom the entire scene without altering the way that your drawable objects are drawn.</para><para>A view is composed of a source rectangle, which defines what part of the 2D scene is shown, and a target viewport, which defines where the contents of the source rectangle will be displayed on the render target (window or texture).</para><para>The viewport allows to map the scene to a custom part of the render target, and can be used for split-screen or for displaying a minimap, for example. If the source rectangle has not the same size as the viewport, its contents will be stretched to fit in.</para><para>To apply a view, you have to assign it to the render target. Then, every objects drawn in this render target will be affected by the view until you use another view.</para><para>Usage example:</para><para>
  <programlisting><codeline><highlight class="normal"><ref refid="classgf_1_1_render_window" kindref="compound">gf::RenderWindow</ref><sp/>renderer;</highlight></codeline>
<codeline><highlight class="normal"><ref refid="classgf_1_1_view" kindref="compound">gf::View</ref><sp/>view;</highlight></codeline>
<codeline><highlight class="normal"/></codeline>
<codeline><highlight class="normal"/><highlight class="comment">//<sp/>Initialize<sp/>the<sp/>view<sp/>to<sp/>a<sp/>rectangle<sp/>located<sp/>at<sp/>(100,<sp/>100)<sp/>and</highlight><highlight class="normal"/></codeline>
<codeline><highlight class="normal"/><highlight class="comment">//<sp/>with<sp/>a<sp/>size<sp/>of<sp/>400x200</highlight><highlight class="normal"/></codeline>
<codeline><highlight class="normal">view.<ref refid="classgf_1_1_view_1a4a8327e3636d0e65b1202185891947cd" kindref="member">reset</ref>({<sp/>100.0f,<sp/>100.0f,<sp/>400.0f,<sp/>200.0f<sp/>});</highlight></codeline>
<codeline><highlight class="normal"/></codeline>
<codeline><highlight class="normal"/><highlight class="comment">//<sp/>Rotate<sp/>it<sp/>by<sp/>45<sp/>degrees</highlight><highlight class="normal"/></codeline>
<codeline><highlight class="normal">view.<ref refid="classgf_1_1_view_1a29093517f27574b493b6b032bed2b81d" kindref="member">rotate</ref>(<ref refid="group__core_1gafea71ec62ea0c47eb8e65dba77940b40" kindref="member">gf::Pi</ref><sp/>/<sp/>4);</highlight></codeline>
<codeline><highlight class="normal"/></codeline>
<codeline><highlight class="normal"/><highlight class="comment">//<sp/>Set<sp/>its<sp/>target<sp/>viewport<sp/>to<sp/>be<sp/>half<sp/>of<sp/>the<sp/>window</highlight><highlight class="normal"/></codeline>
<codeline><highlight class="normal">view.<ref refid="classgf_1_1_view_1a1f39e06d2340af95c897a649a2b86e56" kindref="member">setViewport</ref>({<sp/>0.f,<sp/>0.f,<sp/>0.5f,<sp/>1.f<sp/>});</highlight></codeline>
<codeline><highlight class="normal"/></codeline>
<codeline><highlight class="normal"/><highlight class="comment">//<sp/>Apply<sp/>it</highlight><highlight class="normal"/></codeline>
<codeline><highlight class="normal">renderer.<ref refid="classgf_1_1_render_target_1ad0c0d32d96beabdd18cfdab4c64ee93a" kindref="member">setView</ref>(view);</highlight></codeline>
<codeline><highlight class="normal"/></codeline>
<codeline><highlight class="normal"/><highlight class="comment">//<sp/>Render<sp/>stuff</highlight><highlight class="normal"/></codeline>
<codeline><highlight class="normal">renderer.<ref refid="classgf_1_1_render_target_1a3445880f95c648efbeff3d2572c4c263" kindref="member">draw</ref>(someSprite);</highlight></codeline>
<codeline><highlight class="normal"/></codeline>
<codeline><highlight class="normal"/><highlight class="comment">//<sp/>Set<sp/>the<sp/>default<sp/>view<sp/>back</highlight><highlight class="normal"/></codeline>
<codeline><highlight class="normal">renderer.<ref refid="classgf_1_1_render_target_1ad0c0d32d96beabdd18cfdab4c64ee93a" kindref="member">setView</ref>(renderer.getDefaultView());</highlight></codeline>
<codeline><highlight class="normal"/></codeline>
<codeline><highlight class="normal"/><highlight class="comment">//<sp/>Render<sp/>stuff<sp/>not<sp/>affected<sp/>by<sp/>the<sp/>view</highlight><highlight class="normal"/></codeline>
<codeline><highlight class="normal">renderer.<ref refid="classgf_1_1_render_target_1a3445880f95c648efbeff3d2572c4c263" kindref="member">draw</ref>(someOtherSprite);</highlight></codeline>
</programlisting>
</para><para><simplesect kind="see"><para><ref refid="classgf_1_1_render_target" kindref="compound">gf::RenderTarget</ref>, gf::AdaptiveView </para></simplesect>
</para><br>

        
            
        
            
        
            
        
        <br>
    

    
        - <compoundname>gf::ViewContainer</compoundname><br>
        Brief desc: <para>A container of views. </para><br>
        Full desc: <para>A view manager handles several adaptive views. It can update all the views at the same time. All it needs is the events that come from the window.</para><para>Here is a full example with two adaptive views:</para><para><programlisting><codeline><highlight class="normal"><sp/><sp/><ref refid="classgf_1_1_view_container" kindref="compound">gf::ViewContainer</ref><sp/>views;</highlight></codeline>
<codeline><highlight class="normal"/></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="classgf_1_1_extend_view" kindref="compound">gf::ExtendView</ref><sp/>extendView;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>extendView.<ref refid="classgf_1_1_view_1a76879d7542b0bcb2fcf75daf5e6009f8" kindref="member">setSize</ref>(ViewSize);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>views.<ref refid="classgf_1_1_view_container_1aa3eba860cd2fb8cb9ac11e06b81c4389" kindref="member">addView</ref>(extendView);</highlight></codeline>
<codeline><highlight class="normal"/></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="classgf_1_1_screen_view" kindref="compound">gf::ScreenView</ref><sp/>screenView;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>views.<ref refid="classgf_1_1_view_container_1aa3eba860cd2fb8cb9ac11e06b81c4389" kindref="member">addView</ref>(screenView);</highlight></codeline>
<codeline><highlight class="normal"/></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>initialize<sp/>the<sp/>views<sp/>with<sp/>the<sp/>initial<sp/>screen<sp/>size</highlight><highlight class="normal"/></codeline>
<codeline><highlight class="normal"><sp/><sp/>views.<ref refid="classgf_1_1_view_container_1af1c6132257c4838da5c0db61793a18cd" kindref="member">setInitialScreenSize</ref>(ScreenSize);</highlight></codeline>
<codeline><highlight class="normal"/></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>...</highlight><highlight class="normal"/></codeline>
<codeline><highlight class="normal"/></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(window.<ref refid="classgf_1_1_window_1af0d0f974e8edfd10db47fc8040a5874f" kindref="member">isOpen</ref>())<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structgf_1_1_event" kindref="compound">gf::Event</ref><sp/>event;</highlight></codeline>
<codeline><highlight class="normal"/></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(window.<ref refid="classgf_1_1_window_1a88c202262d1e22f23f164247381deaa6" kindref="member">pollEvent</ref>(event))<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>...</highlight><highlight class="normal"/></codeline>
<codeline><highlight class="normal"/></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>views.<ref refid="classgf_1_1_view_container_1a61734888f06a8c8629c39c78a7346639" kindref="member">processEvent</ref>(event);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"/></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>...</highlight><highlight class="normal"/></codeline>
<codeline><highlight class="normal"/></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>renderer.<ref refid="classgf_1_1_render_target_1a2c3f888d184e81d8668b6ec5b1d332de" kindref="member">clear</ref>();</highlight></codeline>
<codeline><highlight class="normal"/></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>renderer.<ref refid="classgf_1_1_render_target_1ad0c0d32d96beabdd18cfdab4c64ee93a" kindref="member">setView</ref>(extendView);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>renderer.<ref refid="classgf_1_1_render_target_1a3445880f95c648efbeff3d2572c4c263" kindref="member">draw</ref>(sprite);</highlight></codeline>
<codeline><highlight class="normal"/></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>renderer.<ref refid="classgf_1_1_render_target_1ad0c0d32d96beabdd18cfdab4c64ee93a" kindref="member">setView</ref>(screenView);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>renderer.<ref refid="classgf_1_1_render_target_1a3445880f95c648efbeff3d2572c4c263" kindref="member">draw</ref>(ui);</highlight></codeline>
<codeline><highlight class="normal"/></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>renderer.<ref refid="classgf_1_1_render_window_1a1d4ad6ad8831957e277a173923ec4720" kindref="member">display</ref>();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
</programlisting> <simplesect kind="see"><para><ref refid="classgf_1_1_adaptative_view" kindref="compound">gf::AdaptativeView</ref> </para></simplesect>
</para><br>

        
            
        
            
        
        <br>
    

    
        - <compoundname>gf::WaveletNoise3D</compoundname><br>
        Brief desc: <para>Wavelet 3D noise. </para><br>
        Full desc: <para><simplesect kind="see"><para><ulink url="https://graphics.pixar.com/library/WaveletNoise/paper.pdf">Wavelet Noise. Robert L. Cook, Tony DeRose, Pixar Animation Studios.</ulink> </para></simplesect>
</para><br>

        
            
        
            
        
        <br>
    

    
        - <compoundname>gf::Window</compoundname><br>
        Brief desc: <para>An OS window. </para><br>
        Full desc: <para>The <ref refid="classgf_1_1_window" kindref="compound">gf::Window</ref> class provides a simple interface for manipulating the window: move, resize, show/hide, control mouse cursor, etc. It also provides event handling through its <ref refid="classgf_1_1_window_1a88c202262d1e22f23f164247381deaa6" kindref="member">pollEvent()</ref> and <ref refid="classgf_1_1_window_1a9d0c88cab494e08929fac337fee090f6" kindref="member">waitEvent()</ref> functions.</para><para><programlisting><codeline><highlight class="normal"><sp/><sp/><ref refid="classgf_1_1_window" kindref="compound">gf::Window</ref><sp/>window(</highlight><highlight class="stringliteral">"My<sp/>window"</highlight><highlight class="normal">,<sp/>{<sp/>640,<sp/>480<sp/>},<sp/><ref refid="group__window_1gga62cc170c1e16539e4bad1d9f27c6b752aaff10bf1618da00a8a80b74044e719b2" kindref="member">gf::WindowHints::Resizable</ref><sp/>|<sp/><ref refid="group__game_1ggad82e9592419fd671caafe4af9b4f89e7aec24d78ce33048dc73a2b6b1a0690192" kindref="member">gf::WindowHints::Visible</ref>);</highlight></codeline>
<codeline><highlight class="normal"/></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(window.<ref refid="classgf_1_1_window_1af0d0f974e8edfd10db47fc8040a5874f" kindref="member">isOpen</ref>())<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>process<sp/>events</highlight><highlight class="normal"/></codeline>
<codeline><highlight class="normal"/></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="structgf_1_1_event" kindref="compound">gf::Event</ref><sp/>event;</highlight></codeline>
<codeline><highlight class="normal"/></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(window.<ref refid="classgf_1_1_window_1a88c202262d1e22f23f164247381deaa6" kindref="member">pollEvent</ref>(event))<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(event.<ref refid="structgf_1_1_event_1a764707270173af5b617ed6589a58dfe1" kindref="member">type</ref><sp/>==<sp/><ref refid="group__window_1gga244fb10415539f03cde7ed0ae916018da03f4a47830f97377a35321051685071e" kindref="member">gf::EventType::Closed</ref>)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>window.<ref refid="classgf_1_1_window_1a653d8e56d4c27da4aced0dc702edb8a8" kindref="member">close</ref>();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"/></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>...</highlight><highlight class="normal"/></codeline>
<codeline><highlight class="normal"/></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
</programlisting> <simplesect kind="see"><para><ref refid="classgf_1_1_render_window" kindref="compound">gf::RenderWindow</ref> </para></simplesect>
</para><br>

        
            

                <br><strong>Section: </strong>
                <header>Window's lifecycle</header><br>

                
                    - <name>isOpen</name><br>
                
                    - <name>close</name><br>
                

            
        
            

                <br><strong>Section: </strong>
                <header>Window's positon and size</header><br>

                
                    - <name>setTitle</name><br>
                
                    - <name>getPosition</name><br>
                
                    - <name>setPosition</name><br>
                
                    - <name>getSize</name><br>
                
                    - <name>setSize</name><br>
                
                    - <name>getFramebufferSize</name><br>
                
                    - <name>setFullscreen</name><br>
                
                    - <name>toggleFullscreen</name><br>
                
                    - <name>isFullscreen</name><br>
                

            
        
            

                <br><strong>Section: </strong>
                <header>Window's state</header><br>

                
                    - <name>minimize</name><br>
                
                    - <name>restore</name><br>
                
                    - <name>maximize</name><br>
                
                    - <name>show</name><br>
                
                    - <name>hide</name><br>
                
                    - <name>setVisible</name><br>
                
                    - <name>setDecorated</name><br>
                
                    - <name>isFocused</name><br>
                
                    - <name>isMinimized</name><br>
                
                    - <name>isResizable</name><br>
                
                    - <name>isVisible</name><br>
                
                    - <name>isDecorated</name><br>
                

            
        
            

                <br><strong>Section: </strong>
                <header>Event handling</header><br>

                
                    - <name>pollEvent</name><br>
                
                    - <name>waitEvent</name><br>
                

            
        
            

                <br><strong>Section: </strong>
                <header>Display</header><br>

                
                    - <name>setVerticalSyncEnabled</name><br>
                
                    - <name>isVerticalSyncEnabled</name><br>
                
                    - <name>setFramerateLimit</name><br>
                
                    - <name>display</name><br>
                

            
        
            

                <br><strong>Section: </strong>
                <header>Input management</header><br>

                
                    - <name>setMouseCursorVisible</name><br>
                
                    - <name>setMouseCursorGrabbed</name><br>
                
                    - <name>setMouseCursor</name><br>
                

            
        
            
        
            
        
        <br>
    

    
        - <compoundname>gf::WorleyNoise2D</compoundname><br>
        Brief desc: <para>Worley 2D noise. </para><br>
        Full desc: <para><ulink url="https://en.wikipedia.org/wiki/Worley_noise">Worley noise</ulink> is a point based noise. It is also known as Voronoi noise or cellular noise or simply cell noise. </para><br>

        
            
        
            
        
        <br>
    

    
        - <compoundname>gf::ZoomingViewAdaptor</compoundname><br>
        Brief desc: <para>A view adaptor for zooming/moving with the mouse. </para><br>
        Full desc: <br>

        
            
        
            
        
            
        
        <br>
    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    

    



<h3>Structs:</h3>










- <compoundname>gf::AllType</compoundname> <br>
<para>Semantic type to represent "all". </para>
<br>























- <compoundname>gf::BlendMode</compoundname> <br>
<para>Blending modes for drawing. </para>
<br>











- <compoundname>gf::Console::Cell</compoundname> <br>

<br>



- <compoundname>gf::Circ</compoundname> <br>
<para>Utility class for manipulating circles. </para>
<br>













- <compoundname>gf::Color</compoundname> <br>
<para>Predefined colors. </para>
<br>







- <compoundname>gf::Console::ColorControl</compoundname> <br>

<br>









- <compoundname>gf::ColorRamp</compoundname> <br>
<para>A color ramp. </para>
<br>







- <compoundname>gf::ConsoleChar</compoundname> <br>
<para>Named console characters. </para>
<br>







- <compoundname>gf::ConsoleFontElement</compoundname> <br>
<para>A console font element. </para>
<br>



- <compoundname>gf::ConsoleFontFormat</compoundname> <br>
<para>A console font format. </para>
<br>































- <compoundname>gf::Event</compoundname> <br>
<para>Defines a system event and its parameters. </para>
<br>

















- <compoundname>gf::GraphicsInfo::Format</compoundname> <br>
<para>An OpenGL format. </para>
<br>







- <compoundname>gf::Animation::Frame</compoundname> <br>

<br>







- <compoundname>gf::Event::GamepadAxisEvent</compoundname> <br>
<para><ref refid="classgf_1_1_gamepad" kindref="compound">Gamepad</ref> axis event parameters (<ref refid="group__window_1gga244fb10415539f03cde7ed0ae916018da18389e2bd7b6b426f7b9d9164bf4a5ba" kindref="member">EventType::GamepadAxisMoved</ref>) </para>
<br>





- <compoundname>gf::Event::GamepadButtonEvent</compoundname> <br>
<para><ref refid="classgf_1_1_gamepad" kindref="compound">Gamepad</ref> button event parameters (<ref refid="group__window_1gga244fb10415539f03cde7ed0ae916018dae2a9941e644616b8853693e7b3b22c96" kindref="member">EventType::GamepadButtonPressed</ref>, <ref refid="group__window_1gga244fb10415539f03cde7ed0ae916018daf4590195d79da4a322ee9beb6b44ef66" kindref="member">EventType::GamepadButtonReleased</ref>) </para>
<br>



- <compoundname>gf::Event::GamepadConnection</compoundname> <br>
<para><ref refid="classgf_1_1_gamepad" kindref="compound">Gamepad</ref> connection event parameters (<ref refid="group__window_1gga244fb10415539f03cde7ed0ae916018dad5909d240c46150dc002123ef8abcc2f" kindref="member">EventType::GamepadConnected</ref>) </para>
<br>



- <compoundname>gf::Event::GamepadDisconnection</compoundname> <br>
<para><ref refid="classgf_1_1_gamepad" kindref="compound">Gamepad</ref> disconnection event parameters (<ref refid="group__window_1gga244fb10415539f03cde7ed0ae916018dac1c12a889ebdc886dc3738b5a146def0" kindref="member">EventType::GamepadDisconnected</ref>) </para>
<br>



- <compoundname>gf::Glyph</compoundname> <br>
<para>A glyph. </para>
<br>



- <compoundname>gf::Font::GlyphCache</compoundname> <br>

<br>









- <compoundname>gf::MessageManager::Handler</compoundname> <br>

<br>













- <compoundname>gf::Range::Iterator</compoundname> <br>
<para>A range iterator. </para>
<br>



- <compoundname>gf::PositionRange::Iterator</compoundname> <br>
<para>An iterator for a 2D range. </para>
<br>



- <compoundname>gf::Keyboard</compoundname> <br>
<para>Some keyboard related functions. </para>
<br>





- <compoundname>gf::Event::KeyEvent</compoundname> <br>
<para><ref refid="structgf_1_1_keyboard" kindref="compound">Keyboard</ref> event parameters (<ref refid="group__window_1gga244fb10415539f03cde7ed0ae916018dac17e6984c1e5a887a49831beadee6bca" kindref="member">EventType::KeyPressed</ref>, <ref refid="group__window_1gga244fb10415539f03cde7ed0ae916018da4a77f07c8ad223b71ab4ce78a63841ab" kindref="member">EventType::KeyReleased</ref>, <ref refid="group__window_1gga244fb10415539f03cde7ed0ae916018da7ee0b7f842e837fe969eb195acaf2efd" kindref="member">EventType::KeyRepeated</ref>) </para>
<br>





- <compoundname>gf::Text::Line</compoundname> <br>

<br>





- <compoundname>gf::RenderTarget::Locations</compoundname> <br>

<br>









- <compoundname>gf::Matrix</compoundname> <br>
<para>General purpose math matrix. </para>
<br>



- <compoundname>gf::Matrix&lt; T, 2, 2 &gt;</compoundname> <br>
<para>A 2x2 matrix. </para>
<br>



- <compoundname>gf::Matrix&lt; T, 3, 3 &gt;</compoundname> <br>
<para>A 3x3 matrix. </para>
<br>



- <compoundname>gf::Matrix&lt; T, 4, 4 &gt;</compoundname> <br>
<para>A 4x4 matrix. </para>
<br>





- <compoundname>gf::Message</compoundname> <br>
<para>The base class for all messages. </para>
<br>













- <compoundname>gf::Event::MouseButtonEvent</compoundname> <br>
<para>Mouse button event parameters (<ref refid="group__window_1gga244fb10415539f03cde7ed0ae916018da7349f643d689997b7c54bf93e4095f5c" kindref="member">EventType::MouseButtonPressed</ref>, <ref refid="group__window_1gga244fb10415539f03cde7ed0ae916018da7584c169de594c27f00084b93186fd7c" kindref="member">EventType::MouseButtonReleased</ref>) </para>
<br>



- <compoundname>gf::Event::MouseCursorEvent</compoundname> <br>
<para>Mouse cursor move event parameters (<ref refid="group__window_1gga244fb10415539f03cde7ed0ae916018dac2770ad109c8063ce69a3608a9a16c08" kindref="member">EventType::MouseMoved</ref>) </para>
<br>



- <compoundname>gf::Event::MouseWheelEvent</compoundname> <br>
<para>Mouse wheel event parameters (<ref refid="group__window_1gga244fb10415539f03cde7ed0ae916018da9787e93d7821ce61637e6f9f19ef955b" kindref="member">EventType::MouseWheelScrolled</ref>) </para>
<br>















- <compoundname>gf::NoneType</compoundname> <br>
<para>Semantic type to represent "none". </para>
<br>







- <compoundname>gf::Font::Packing</compoundname> <br>

<br>



- <compoundname>gf::Text::Paragraph</compoundname> <br>

<br>





- <compoundname>gf::Paths</compoundname> <br>
<para>Special paths. </para>
<br>



- <compoundname>gf::Penetration</compoundname> <br>
<para>Data about the collision between two objects. </para>
<br>





















- <compoundname>gf::PositionRange</compoundname> <br>
<para>A 2D range. </para>
<br>





- <compoundname>gf::PredefinedConsoleFontFormat</compoundname> <br>
<para>Predefined console font formats. </para>
<br>









- <compoundname>gf::Range</compoundname> <br>
<para>A half-open range of values. </para>
<br>



- <compoundname>gf::Rect</compoundname> <br>
<para>Utility class for manipulating 2D axis aligned rectangles. </para>
<br>





- <compoundname>gf::Region</compoundname> <br>
<para>A region of a window. </para>
<br>





- <compoundname>gf::RenderStates</compoundname> <br>
<para>Define the states used for drawing to a <ref refid="classgf_1_1_render_target" kindref="compound">RenderTarget</ref>. </para>
<br>



















- <compoundname>gf::Rotation</compoundname> <br>
<para>A rotation. </para>
<br>





- <compoundname>gf::Rune</compoundname> <br>
<para>A character encoded in UTF-8. </para>
<br>











































- <compoundname>gf::Event::TextEvent</compoundname> <br>
<para><ref refid="classgf_1_1_text" kindref="compound">Text</ref> event parameters (<ref refid="group__window_1gga244fb10415539f03cde7ed0ae916018da8ed4d3c0783d6f909907e1592ffe47ac" kindref="member">EventType::TextEntered</ref>) </para>
<br>







- <compoundname>gf::RenderPipeline::TextureBuffer</compoundname> <br>

<br>







- <compoundname>gf::TmxAnimation</compoundname> <br>
<para>A tile animation. </para>
<br>



- <compoundname>gf::TmxCell</compoundname> <br>
<para>A cell in a tile layer. </para>
<br>



- <compoundname>gf::TmxEllipse</compoundname> <br>
<para>An ellipse object. </para>
<br>



- <compoundname>gf::TmxFrame</compoundname> <br>
<para>A frame in a tile animation. </para>
<br>



- <compoundname>gf::TmxGroupLayer</compoundname> <br>
<para>A layer with other layers. </para>
<br>



- <compoundname>gf::TmxImage</compoundname> <br>
<para>A reference to an image. </para>
<br>



- <compoundname>gf::TmxImageLayer</compoundname> <br>
<para>A layer with an image. </para>
<br>



- <compoundname>gf::TmxLayer</compoundname> <br>
<para>A layer in the whole map. </para>
<br>



- <compoundname>gf::TmxLayers</compoundname> <br>
<para>A TMX map. </para>
<br>



- <compoundname>gf::TmxObject</compoundname> <br>
<para>A geometrical object. </para>
<br>



- <compoundname>gf::TmxObjectLayer</compoundname> <br>
<para>A layer with objects. </para>
<br>



- <compoundname>gf::TmxPolygon</compoundname> <br>
<para>A polygon object. </para>
<br>



- <compoundname>gf::TmxPolyline</compoundname> <br>
<para>A polyline object. </para>
<br>





- <compoundname>gf::TmxRectangle</compoundname> <br>
<para>A rectangle object. </para>
<br>



- <compoundname>gf::TmxTerrain</compoundname> <br>
<para>A description of a kind of terrain on the map. </para>
<br>



- <compoundname>gf::TmxText</compoundname> <br>
<para>A text object. </para>
<br>



- <compoundname>gf::TmxTile</compoundname> <br>
<para>A rectangular part of a tileset. </para>
<br>



- <compoundname>gf::TmxTileLayer</compoundname> <br>
<para>A layer with tiles in cells. </para>
<br>



- <compoundname>gf::TmxTileObject</compoundname> <br>
<para>An image put in the map identified by its global id. </para>
<br>



- <compoundname>gf::TmxTileset</compoundname> <br>
<para>A set of tiles in a single file (image or TSX file) </para>
<br>





- <compoundname>gf::Transform</compoundname> <br>
<para>A simple transformation (rotation then translation) </para>
<br>





- <compoundname>gf::Translation</compoundname> <br>
<para>A translation. </para>
<br>







- <compoundname>gf::UIBrowser</compoundname> <br>
<para>Data for file selector. </para>
<br>



- <compoundname>gf::UIEditType</compoundname> <br>
<para>Predefined flags for edit. </para>
<br>







- <compoundname>gf::Vector</compoundname> <br>
<para>General purpose math vector. </para>
<br>



- <compoundname>gf::Vector&lt; T, 2 &gt;</compoundname> <br>
<para>A 2D vector. </para>
<br>



- <compoundname>gf::Vector&lt; T, 3 &gt;</compoundname> <br>
<para>A 3D vector. </para>
<br>



- <compoundname>gf::Vector&lt; T, 4 &gt;</compoundname> <br>
<para>A 4D vector. </para>
<br>



- <compoundname>gf::Library::Version</compoundname> <br>
<para>Information about version. </para>
<br>



- <compoundname>gf::Vertex</compoundname> <br>
<para>A point associated with a color and a texture coordinate. </para>
<br>







- <compoundname>gf::VideoMode</compoundname> <br>
<para>A video mode. </para>
<br>



































































































































































































































































































































































<h3>Unions:</h3>

































































































































































































































































































































































































































































































































































































































































































































































































































<h3>Interfaces:</h3>

































































































































































































































































































































































































































































































































































































































































































































































































































<h3>Protocoles:</h3>

































































































































































































































































































































































































































































































































































































































































































































































































































<h3>Categories:</h3>

































































































































































































































































































































































































































































































































































































































































































































































































































<h3>Exceptions:</h3>

































































































































































































































































































































































































































































































































































































































































































































































































































<h3>Files:</h3>




















































































































































































































































































































































































































































































- <compoundname>Action.h</compoundname> <br>

<br>



- <compoundname>Activities.h</compoundname> <br>

<br>



- <compoundname>Activity.h</compoundname> <br>

<br>



- <compoundname>Alignment.h</compoundname> <br>

<br>



- <compoundname>Anchor.h</compoundname> <br>

<br>



- <compoundname>AnimatedSprite.h</compoundname> <br>

<br>



- <compoundname>Animation.h</compoundname> <br>

<br>



- <compoundname>Array2D.h</compoundname> <br>

<br>



- <compoundname>ArrayRef.h</compoundname> <br>

<br>



- <compoundname>AssetManager.h</compoundname> <br>

<br>



- <compoundname>Blend.h</compoundname> <br>

<br>



- <compoundname>BufferedGeometry.h</compoundname> <br>

<br>



- <compoundname>BufferRef.h</compoundname> <br>

<br>



- <compoundname>build_and_install.dox</compoundname> <br>

<br>



- <compoundname>Circ.h</compoundname> <br>

<br>



- <compoundname>Clipboard.h</compoundname> <br>

<br>



- <compoundname>Clock.h</compoundname> <br>

<br>



- <compoundname>Collision.h</compoundname> <br>

<br>



- <compoundname>Color.h</compoundname> <br>

<br>



- <compoundname>ColorRamp.h</compoundname> <br>

<br>



- <compoundname>Console.h</compoundname> <br>

<br>



- <compoundname>ConsoleChar.h</compoundname> <br>

<br>



- <compoundname>ConsoleFont.h</compoundname> <br>

<br>



- <compoundname>Control.h</compoundname> <br>

<br>



- <compoundname>Controls.h</compoundname> <br>

<br>



- <compoundname>Coordinates.h</compoundname> <br>

<br>



- <compoundname>Cursor.h</compoundname> <br>

<br>



- <compoundname>Curve.h</compoundname> <br>

<br>



- <compoundname>Curves.h</compoundname> <br>

<br>



- <compoundname>devel.dox</compoundname> <br>

<br>



- <compoundname>differences_with_sfml.dox</compoundname> <br>

<br>



- <compoundname>Direction.h</compoundname> <br>

<br>



- <compoundname>documentation.dox</compoundname> <br>

<br>



- <compoundname>Drawable.h</compoundname> <br>

<br>



- <compoundname>Easings.h</compoundname> <br>

<br>



- <compoundname>Effect.h</compoundname> <br>

<br>



- <compoundname>Effects.h</compoundname> <br>

<br>



- <compoundname>Entity.h</compoundname> <br>

<br>



- <compoundname>EntityContainer.h</compoundname> <br>

<br>



- <compoundname>Event.h</compoundname> <br>

<br>



- <compoundname>events_controls_actions.dox</compoundname> <br>

<br>



- <compoundname>features.dox</compoundname> <br>

<br>



- <compoundname>Flags.h</compoundname> <br>

<br>



- <compoundname>Font.h</compoundname> <br>

<br>



- <compoundname>gamedev_101.dox</compoundname> <br>

<br>



- <compoundname>Gamepad.h</compoundname> <br>

<br>



- <compoundname>Geometry.h</compoundname> <br>

<br>



- <compoundname>GF.h</compoundname> <br>

<br>



- <compoundname>GraphicsInfo.h</compoundname> <br>

<br>



- <compoundname>Grid.h</compoundname> <br>

<br>



- <compoundname>Heightmap.h</compoundname> <br>

<br>



- <compoundname>Id.h</compoundname> <br>

<br>



- <compoundname>Image.h</compoundname> <br>

<br>



- <compoundname>index.dox</compoundname> <br>

<br>



- <compoundname>InputStream.h</compoundname> <br>

<br>



- <compoundname>InputStreams.h</compoundname> <br>

<br>



- <compoundname>Keyboard.h</compoundname> <br>

<br>



- <compoundname>Library.h</compoundname> <br>

<br>



- <compoundname>Log.h</compoundname> <br>

<br>



- <compoundname>Logo.h</compoundname> <br>

<br>



- <compoundname>Map.h</compoundname> <br>

<br>



- <compoundname>math.dox</compoundname> <br>

<br>



- <compoundname>Math.h</compoundname> <br>

<br>



- <compoundname>Matrix.h</compoundname> <br>

<br>



- <compoundname>Message.h</compoundname> <br>

<br>



- <compoundname>MessageManager.h</compoundname> <br>

<br>



- <compoundname>messages.dox</compoundname> <br>

<br>



- <compoundname>Model.h</compoundname> <br>

<br>



- <compoundname>ModelContainer.h</compoundname> <br>

<br>



- <compoundname>Models.h</compoundname> <br>

<br>



- <compoundname>Monitor.h</compoundname> <br>

<br>



- <compoundname>Mouse.h</compoundname> <br>

<br>



- <compoundname>NinePatch.h</compoundname> <br>

<br>



- <compoundname>Noise.h</compoundname> <br>

<br>



- <compoundname>Noises.h</compoundname> <br>

<br>



- <compoundname>opengl.dox</compoundname> <br>

<br>



- <compoundname>Orientation.h</compoundname> <br>

<br>



- <compoundname>Particles.h</compoundname> <br>

<br>



- <compoundname>Path.h</compoundname> <br>

<br>



- <compoundname>Paths.h</compoundname> <br>

<br>



- <compoundname>PhysicsBody.h</compoundname> <br>

<br>



- <compoundname>PhysicsGeometry.h</compoundname> <br>

<br>



- <compoundname>PhysicsModel.h</compoundname> <br>

<br>



- <compoundname>Polygon.h</compoundname> <br>

<br>



- <compoundname>Polyline.h</compoundname> <br>

<br>



- <compoundname>Portability.h</compoundname> <br>

<br>



- <compoundname>PostProcessing.h</compoundname> <br>

<br>



- <compoundname>PrimitiveType.h</compoundname> <br>

<br>



- <compoundname>procedural_generation.dox</compoundname> <br>

<br>



- <compoundname>Queue.h</compoundname> <br>

<br>



- <compoundname>Random.h</compoundname> <br>

<br>



- <compoundname>Range.h</compoundname> <br>

<br>



- <compoundname>recommanded_libraries.dox</compoundname> <br>

<br>



- <compoundname>Rect.h</compoundname> <br>

<br>



- <compoundname>references.dox</compoundname> <br>

<br>



- <compoundname>Region.h</compoundname> <br>

<br>



- <compoundname>RenderPipeline.h</compoundname> <br>

<br>



- <compoundname>RenderStates.h</compoundname> <br>

<br>



- <compoundname>RenderTarget.h</compoundname> <br>

<br>



- <compoundname>RenderTexture.h</compoundname> <br>

<br>



- <compoundname>RenderWindow.h</compoundname> <br>

<br>



- <compoundname>ResourceManager.h</compoundname> <br>

<br>



- <compoundname>road_to_v1.dox</compoundname> <br>

<br>



- <compoundname>Rune.h</compoundname> <br>

<br>



- <compoundname>shader.dox</compoundname> <br>

<br>



- <compoundname>Shader.h</compoundname> <br>

<br>



- <compoundname>Shape.h</compoundname> <br>

<br>



- <compoundname>Shapes.h</compoundname> <br>

<br>



- <compoundname>Singleton.h</compoundname> <br>

<br>



- <compoundname>singletons.dox</compoundname> <br>

<br>



- <compoundname>Sleep.h</compoundname> <br>

<br>



- <compoundname>SpaceTree.h</compoundname> <br>

<br>



- <compoundname>Sprite.h</compoundname> <br>

<br>



- <compoundname>SpriteBatch.h</compoundname> <br>

<br>



- <compoundname>start_game.dox</compoundname> <br>

<br>



- <compoundname>StringRef.h</compoundname> <br>

<br>



- <compoundname>StringUtils.h</compoundname> <br>

<br>



- <compoundname>SystemInfo.h</compoundname> <br>

<br>



- <compoundname>Text.h</compoundname> <br>

<br>



- <compoundname>Texture.h</compoundname> <br>

<br>



- <compoundname>TextureAtlas.h</compoundname> <br>

<br>



- <compoundname>TileLayer.h</compoundname> <br>

<br>



- <compoundname>Time.h</compoundname> <br>

<br>



- <compoundname>Tmx.h</compoundname> <br>

<br>



- <compoundname>Transform.h</compoundname> <br>

<br>



- <compoundname>Transformable.h</compoundname> <br>

<br>



- <compoundname>Tween.h</compoundname> <br>

<br>



- <compoundname>Types.h</compoundname> <br>

<br>



- <compoundname>UI.h</compoundname> <br>

<br>



- <compoundname>Unused.h</compoundname> <br>

<br>



- <compoundname>use.dox</compoundname> <br>

<br>



- <compoundname>Vector.h</compoundname> <br>

<br>



- <compoundname>VectorOps.h</compoundname> <br>

<br>



- <compoundname>vectors_matrices_transforms.dox</compoundname> <br>

<br>



- <compoundname>Vertex.h</compoundname> <br>

<br>



- <compoundname>VertexArray.h</compoundname> <br>

<br>



- <compoundname>VertexBuffer.h</compoundname> <br>

<br>



- <compoundname>View.h</compoundname> <br>

<br>



- <compoundname>ViewContainer.h</compoundname> <br>

<br>



- <compoundname>Views.h</compoundname> <br>

<br>



- <compoundname>Window.h</compoundname> <br>

<br>






















































<h3>Namespaces:</h3>














































































































































































































































































































































































































































































- <compoundname>gf</compoundname> <br>
<para>The namespace for gf classes. </para>
<br>



- <compoundname>gf::literals</compoundname> <br>
<para>The namespace for literals. </para>
<br>



- <compoundname>std</compoundname> <br>
<para>STL namespace. </para>
<br>
















































































































































































































































































































































<h3>Groups:</h3>














































































































































































































































































































































































































































































































































































































































































































































































- <compoundname>core</compoundname> <br>
<para>All the core generic classes and functions. </para>
<br>



- <compoundname>window</compoundname> <br>
<para>All the classes related to window management. </para>
<br>



- <compoundname>graphics</compoundname> <br>
<para>All the classes related to graphics. </para>
<br>



- <compoundname>game</compoundname> <br>
<para>All the classes related to game systems and game entities. </para>
<br>














































<h3>Pages:</h3>






















































































































































































































































































































































































































































































































































































































































































































































































- <compoundname>build_and_install</compoundname> <br>

<br>



- <compoundname>devel</compoundname> <br>

<br>



- <compoundname>differences_with_sfml</compoundname> <br>

<br>



- <compoundname>documentation</compoundname> <br>

<br>



- <compoundname>events_controls_actions</compoundname> <br>

<br>



- <compoundname>features</compoundname> <br>

<br>



- <compoundname>gamedev_101</compoundname> <br>

<br>



- <compoundname>math</compoundname> <br>

<br>



- <compoundname>messages</compoundname> <br>

<br>



- <compoundname>opengl</compoundname> <br>

<br>



- <compoundname>pcg</compoundname> <br>

<br>



- <compoundname>recommanded_libraries</compoundname> <br>

<br>



- <compoundname>references</compoundname> <br>

<br>



- <compoundname>road_to_v1</compoundname> <br>

<br>



- <compoundname>shader</compoundname> <br>

<br>



- <compoundname>singletons</compoundname> <br>

<br>



- <compoundname>start_game</compoundname> <br>

<br>



- <compoundname>use</compoundname> <br>

<br>



- <compoundname>vectors_matrices_transforms</compoundname> <br>

<br>







- <compoundname>index</compoundname> <br>

<br>


<h3>Examples:</h3>

































































































































































































































































































































































































































































































































































































































































































































































































































<h3>Directories:</h3>




























































































































































































































































































































































































































































































































































































































































































































































































































- <compoundname>gf</compoundname> <br>

<br>



- <compoundname>include</compoundname> <br>

<br>




</body>
</html>